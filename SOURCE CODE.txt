#include <iostream>
#include <string>
#include <cstdint>
#include <iomanip>
#include <thread>
#include <vector>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <deque>
#include <unordered_map>
#include <fstream>
#include <cmath>
#pragma comment(lib, "ws2_32.lib")
#define DEFAULT_BUFLEN 512
#define _OPEN_SYS_SOCK_IPV6
using namespace std;

//start of mostly copied code

enum {
    h1, g1, f1, e1, d1, c1, b1, a1,
    h2, g2, f2, e2, d2, c2, b2, a2,
    h3, g3, f3, e3, d3, c3, b3, a3,
    h4, g4, f4, e4, d4, c4, b4, a4,
    h5, g5, f5, e5, d5, c5, b5, a5,
    h6, g6, f6, e6, d6, c6, b6, a6,
    h7, g7, f7, e7, d7, c7, b7, a7,
    h8, g8, f8, e8, d8, c8, b8, a8, no_sq
};
enum { rook, bishop };
#define get_bit(bitboard, square) (bitboard & (1ULL << square))
#define set_bit(bitboard, square) (bitboard |= ((1ULL) << square))
#define pop_bit(bitboard, square) (get_bit(bitboard, square) ? (bitboard ^= (1ULL << square)) : 0)
const uint64_t knight_magics[64] = {
    0x20400ULL,
    0x50800ULL,
    0xa1100ULL,
    0x142200ULL,
    0x284400ULL,
    0x508800ULL,
    0xa01000ULL,
    0x402000ULL,
    0x2040004ULL,
    0x5080008ULL,
    0xa110011ULL,
    0x14220022ULL,
    0x28440044ULL,
    0x50880088ULL,
    0xa0100010ULL,
    0x40200020ULL,
    0x204000402ULL,
    0x508000805ULL,
    0xa1100110aULL,
    0x1422002214ULL,
    0x2844004428ULL,
    0x5088008850ULL,
    0xa0100010a0ULL,
    0x4020002040ULL,
    0x20400040200ULL,
    0x50800080500ULL,
    0xa1100110a00ULL,
    0x142200221400ULL,
    0x284400442800ULL,
    0x508800885000ULL,
    0xa0100010a000ULL,
    0x402000204000ULL,
    0x2040004020000ULL,
    0x5080008050000ULL,
    0xa1100110a0000ULL,
    0x14220022140000ULL,
    0x28440044280000ULL,
    0x50880088500000ULL,
    0xa0100010a00000ULL,
    0x40200020400000ULL,
    0x204000402000000ULL,
    0x508000805000000ULL,
    0xa1100110a000000ULL,
    0x1422002214000000ULL,
    0x2844004428000000ULL,
    0x5088008850000000ULL,
    0xa0100010a0000000ULL,
    0x4020002040000000ULL,
    0x400040200000000ULL,
    0x800080500000000ULL,
    0x1100110a00000000ULL,
    0x2200221400000000ULL,
    0x4400442800000000ULL,
    0x8800885000000000ULL,
    0x100010a000000000ULL,
    0x2000204000000000ULL,
    0x4020000000000ULL,
    0x8050000000000ULL,
    0x110a0000000000ULL,
    0x22140000000000ULL,
    0x44280000000000ULL,
    0x88500000000000ULL,
    0x10a00000000000ULL,
    0x20400000000000ULL,
};
const uint64_t king_magics[64] = {
    0x302ULL,
    0x705ULL,
    0xe0aULL,
    0x1c14ULL,
    0x3828ULL,
    0x7050ULL,
    0xe0a0ULL,
    0xc040ULL,
    0x30203ULL,
    0x70507ULL,
    0xe0a0eULL,
    0x1c141cULL,
    0x382838ULL,
    0x705070ULL,
    0xe0a0e0ULL,
    0xc040c0ULL,
    0x3020300ULL,
    0x7050700ULL,
    0xe0a0e00ULL,
    0x1c141c00ULL,
    0x38283800ULL,
    0x70507000ULL,
    0xe0a0e000ULL,
    0xc040c000ULL,
    0x302030000ULL,
    0x705070000ULL,
    0xe0a0e0000ULL,
    0x1c141c0000ULL,
    0x3828380000ULL,
    0x7050700000ULL,
    0xe0a0e00000ULL,
    0xc040c00000ULL,
    0x30203000000ULL,
    0x70507000000ULL,
    0xe0a0e000000ULL,
    0x1c141c000000ULL,
    0x382838000000ULL,
    0x705070000000ULL,
    0xe0a0e0000000ULL,
    0xc040c0000000ULL,
    0x3020300000000ULL,
    0x7050700000000ULL,
    0xe0a0e00000000ULL,
    0x1c141c00000000ULL,
    0x38283800000000ULL,
    0x70507000000000ULL,
    0xe0a0e000000000ULL,
    0xc040c000000000ULL,
    0x302030000000000ULL,
    0x705070000000000ULL,
    0xe0a0e0000000000ULL,
    0x1c141c0000000000ULL,
    0x3828380000000000ULL,
    0x7050700000000000ULL,
    0xe0a0e00000000000ULL,
    0xc040c00000000000ULL,
    0x203000000000000ULL,
    0x507000000000000ULL,
    0xa0e000000000000ULL,
    0x141c000000000000ULL,
    0x2838000000000000ULL,
    0x5070000000000000ULL,
    0xa0e0000000000000ULL,
    0x40c0000000000000ULL,
};
int rook_rellevant_bits[64] = {
    12, 11, 11, 11, 11, 11, 11, 12,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    12, 11, 11, 11, 11, 11, 11, 12
};
int bishop_rellevant_bits[64] = {
    6, 5, 5, 5, 5, 5, 5, 6,
    5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 7, 7, 7, 7, 5, 5,
    5, 5, 7, 9, 9, 7, 5, 5,
    5, 5, 7, 9, 9, 7, 5, 5,
    5, 5, 7, 7, 7, 7, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5,
    6, 5, 5, 5, 5, 5, 5, 6
};
void print_bitboard(uint64_t bitboard)
{
    printf("\n");

    // loop over board ranks
    for (int rank = 7; rank > -1; rank--)
    {
        // loop over board files
        for (int file = 7; file > -1; file--)
        {
            // init board square
            int square = rank * 8 + file;

            // print ranks
            if (!(file - 7))
                printf("  %d ", rank + 1);

            // print bit indexed by board square
            printf(" %d", get_bit(bitboard, square) ? 1 : 0);
        }

        printf("\n");
    }

    // print files
    printf("\n     a b c d e f g h\n\n");

    // print bitboard as decimal
    printf("     bitboard: %llud\n\n", bitboard);
}
unsigned int state = 1804289383;
unsigned int generate_random_number()
{
    // XOR shift algorithm
    unsigned int x = state;
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    state = x;
    return x;
}
uint64_t random_U64()
{
    // init numbers to randomize
    uint64_t u1, u2, u3, u4;

    // randomize numbers
    u1 = (uint64_t)(generate_random_number()) & 0xFFFF;
    u2 = (uint64_t)(generate_random_number()) & 0xFFFF;
    u3 = (uint64_t)(generate_random_number()) & 0xFFFF;
    u4 = (uint64_t)(generate_random_number()) & 0xFFFF;

    // shuffle bits and return
    return u1 | (u2 << 16) | (u3 << 32) | (u4 << 48);
}
uint64_t random_fewbits() {
    return random_U64() & random_U64() & random_U64();
}
int count_bits(uint64_t bitboard) {
    // bit count
    int count = 0;

    // pop bits untill bitboard is empty
    while (bitboard)
    {
        // increment count
        count++;

        // consecutively reset least significant 1st bit
        bitboard &= bitboard - 1;
    }

    // return bit count
    return count;
}
int get_ls1b_index(unsigned long long bitboard) {
    // make sure bitboard is not empty
    if (bitboard != 0)
        // convert trailing zeros before LS1B to ones and count them
        return count_bits((bitboard & (-1 * bitboard)) - 1);

    // otherwise
    else
        // return illegal index
        return -1;
}
uint64_t set_occupancy(int index, int bits_in_mask, uint64_t attack_mask)
{
    // occupancy map
    uint64_t occupancy = 0ULL;

    // loop over the range of bits within attack mask
    for (int count = 0; count < bits_in_mask; count++)
    {
        // get LS1B index of attacks mask
        int square = get_ls1b_index(attack_mask);

        // pop LS1B in attack map
        pop_bit(attack_mask, square);

        // make sure occupancy is on board
        if (index & (1 << count))
            // populate occupancy map
            occupancy |= (1ULL << square);
    }

    // return occupancy map
    return occupancy;
}
uint64_t mask_bishop_attacks(int square)
{
    // attack bitboard
    uint64_t attacks = 0ULL;

    // init files & ranks
    int f, r;

    // init target files & ranks
    int tr = square / 8;
    int tf = square % 8;

    // generate attacks
    for (r = tr + 1, f = tf + 1; r <= 6 && f <= 6; r++, f++) attacks |= (1ULL << (r * 8 + f));
    for (r = tr + 1, f = tf - 1; r <= 6 && f >= 1; r++, f--) attacks |= (1ULL << (r * 8 + f));
    for (r = tr - 1, f = tf + 1; r >= 1 && f <= 6; r--, f++) attacks |= (1ULL << (r * 8 + f));
    for (r = tr - 1, f = tf - 1; r >= 1 && f >= 1; r--, f--) attacks |= (1ULL << (r * 8 + f));

    // return attack map for bishop on a given square
    return attacks;
}
uint64_t mask_rook_attacks(int square)
{
    // attacks bitboard
    uint64_t attacks = 0ULL;

    // init files & ranks
    int f, r;

    // init target files & ranks
    int tr = square / 8;
    int tf = square % 8;

    // generate attacks
    for (r = tr + 1; r <= 6; r++) attacks |= (1ULL << (r * 8 + tf));
    for (r = tr - 1; r >= 1; r--) attacks |= (1ULL << (r * 8 + tf));
    for (f = tf + 1; f <= 6; f++) attacks |= (1ULL << (tr * 8 + f));
    for (f = tf - 1; f >= 1; f--) attacks |= (1ULL << (tr * 8 + f));

    // return attack map for bishop on a given square
    return attacks;
}
uint64_t bishop_attacks_on_the_fly(int square, uint64_t block)
{
    // attack bitboard
    uint64_t attacks = 0ULL;

    // init files & ranks
    int f, r;

    // init target files & ranks
    int tr = square / 8;
    int tf = square % 8;

    // generate attacks
    for (r = tr + 1, f = tf + 1; r <= 7 && f <= 7; r++, f++)
    {
        attacks |= (1ULL << (r * 8 + f));
        if (block & (1ULL << (r * 8 + f))) break;
    }

    for (r = tr + 1, f = tf - 1; r <= 7 && f >= 0; r++, f--)
    {
        attacks |= (1ULL << (r * 8 + f));
        if (block & (1ULL << (r * 8 + f))) break;
    }

    for (r = tr - 1, f = tf + 1; r >= 0 && f <= 7; r--, f++)
    {
        attacks |= (1ULL << (r * 8 + f));
        if (block & (1ULL << (r * 8 + f))) break;
    }

    for (r = tr - 1, f = tf - 1; r >= 0 && f >= 0; r--, f--)
    {
        attacks |= (1ULL << (r * 8 + f));
        if (block & (1ULL << (r * 8 + f))) break;
    }

    // return attack map for bishop on a given square
    return attacks;
}
uint64_t rook_attacks_on_the_fly(int square, uint64_t block)
{
    // attacks bitboard
    uint64_t attacks = 0ULL;

    // init files & ranks
    int f, r;

    // init target files & ranks
    int tr = square / 8;
    int tf = square % 8;

    // generate attacks
    for (r = tr + 1; r <= 7; r++)
    {
        attacks |= (1ULL << (r * 8 + tf));
        if (block & (1ULL << (r * 8 + tf))) break;
    }

    for (r = tr - 1; r >= 0; r--)
    {
        attacks |= (1ULL << (r * 8 + tf));
        if (block & (1ULL << (r * 8 + tf))) break;
    }

    for (f = tf + 1; f <= 7; f++)
    {
        attacks |= (1ULL << (tr * 8 + f));
        if (block & (1ULL << (tr * 8 + f))) break;
    }

    for (f = tf - 1; f >= 0; f--)
    {
        attacks |= (1ULL << (tr * 8 + f));
        if (block & (1ULL << (tr * 8 + f))) break;
    }

    // return attack map for bishop on a given square
    return attacks;
}
uint64_t find_magic(int square, int relevant_bits, int bishop) {
    // define occupancies array
    uint64_t occupancies[4096];

    // define attacks array
    uint64_t attacks[4096];

    // define used indicies array
    uint64_t used_attacks[4096];

    // mask piece attack
    uint64_t mask_attack = bishop ? mask_bishop_attacks(square) : mask_rook_attacks(square);

    // occupancy variations
    int occupancy_variations = 1 << relevant_bits;

    // loop over the number of occupancy variations
    for (int count = 0; count < occupancy_variations; count++) {
        // init occupancies
        occupancies[count] = set_occupancy(count, relevant_bits, mask_attack);

        // init attacks
        attacks[count] = bishop ? bishop_attacks_on_the_fly(square, occupancies[count]) :
            rook_attacks_on_the_fly(square, occupancies[count]);
    }

    // test magic numbers
    for (int random_count = 0; random_count < 100000000; random_count++)
    {
        // init magic number candidate
        uint64_t magic = random_fewbits();

        // skip testing magic number if inappropriate
        if (count_bits((mask_attack * magic) & 0xFF00000000000000ULL) < 6) continue;

        // reset used attacks array
        memset(used_attacks, 0ULL, sizeof(used_attacks));

        // init count & fail flag
        int count, fail;

        // test magic index
        for (count = 0, fail = 0; !fail && count < occupancy_variations; count++) {
            // generate magic index
            int magic_index = (int)((occupancies[count] * magic) >> (64 - relevant_bits));

            // if got free index
            if (used_attacks[magic_index] == 0ULL)
                // assign corresponding attack map
                used_attacks[magic_index] = attacks[count];

            // otherwise fail on  collision
            else if (used_attacks[magic_index] != attacks[count]) fail = 1;
        }

        // return magic if it works
        if (!fail) return magic;
    }

    // on fail
    printf("***Failed***\n");
    return 0ULL;
}
void init_magics()
{
    printf("const U64 rook_magics[64] = {\n");

    // loop over 64 board squares
    for (int square = 0; square < 64; square++)
        printf("    0x%llxULL,\n", find_magic(square, rook_rellevant_bits[square], 0));

    printf("};\n\nconst U64 bishop_magics[64] = {\n");

    // loop over 64 board squares
    for (int square = 0; square < 64; square++)
        printf("    0x%llxULL,\n", find_magic(square, bishop_rellevant_bits[square], 1));

    printf("};\n\n");
}
void generate_knight_attacks() {
    uint64_t knight_attacks[64];
    int ij, temp1, temp2;
    printf("const U64 knight_magics[64] = {\n");
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            knight_attacks[(ij = i * 8 + j)] = 0;
            if ((temp1 = i - 2) > -1) {
                if ((temp2 = j - 1) > -1)
                    set_bit(knight_attacks[ij], temp1 * 8 + temp2);
                if ((temp2 = j + 1) < 8)
                    set_bit(knight_attacks[ij], temp1 * 8 + temp2);
            }
            if ((temp1 = i + 2) < 8) {
                if ((temp2 = j - 1) > -1)
                    set_bit(knight_attacks[ij], temp1 * 8 + temp2);
                if ((temp2 = j + 1) < 8)
                    set_bit(knight_attacks[ij], temp1 * 8 + temp2);
            }
            if ((temp1 = j - 2) > -1) {
                if ((temp2 = i - 1) > -1)
                    set_bit(knight_attacks[ij], temp2 * 8 + temp1);
                if ((temp2 = i + 1) < 8)
                    set_bit(knight_attacks[ij], temp2 * 8 + temp1);
            }
            if ((temp1 = j + 2) < 8) {
                if ((temp2 = i - 1) > -1)
                    set_bit(knight_attacks[ij], temp2 * 8 + temp1);
                if ((temp2 = i + 1) < 8)
                    set_bit(knight_attacks[ij], temp2 * 8 + temp1);
            }
            printf("\t0x%llxULL,\n", knight_attacks[ij]);
        }
    }
    printf("};\n\n");
}
void generate_king_attacks() {
    uint64_t king_attacks[64];
    int ij, temp1, temp2;
    printf("const U64 king_magics[64] = {\n");
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            king_attacks[(ij = i * 8 + j)] = 0;
            if ((temp1 = i - 1) > -1) {
                set_bit(king_attacks[ij], temp1 * 8 + j);
                if ((temp2 = j - 1) > -1)
                    set_bit(king_attacks[ij], temp1 * 8 + temp2);
                if ((temp2 = j + 1) < 8)
                    set_bit(king_attacks[ij], temp1 * 8 + temp2);
            }
            if ((temp1 = i + 1) < 8) {
                set_bit(king_attacks[ij], temp1 * 8 + j);
                if ((temp2 = j - 1) > -1)
                    set_bit(king_attacks[ij], temp1 * 8 + temp2);
                if ((temp2 = j + 1) < 8)
                    set_bit(king_attacks[ij], temp1 * 8 + temp2);
            }
            if ((temp1 = j - 1) > -1) {
                set_bit(king_attacks[ij], i * 8 + temp1);
                if ((temp2 = i - 1) > -1)
                    set_bit(king_attacks[ij], temp2 * 8 + temp1);
                if ((temp2 = i + 1) < 8)
                    set_bit(king_attacks[ij], temp2 * 8 + temp1);
            }
            if ((temp1 = j + 1) < 8) {
                set_bit(king_attacks[ij], i * 8 + temp1);
                if ((temp2 = i - 1) > -1)
                    set_bit(king_attacks[ij], temp2 * 8 + temp1);
                if ((temp2 = i + 1) < 8)
                    set_bit(king_attacks[ij], temp2 * 8 + temp1);
            }
            printf("\t0x%llxULL,\n", king_attacks[ij]);
        }
    }
    printf("};\n\n");
}
uint64_t bishop_masks[64];
uint64_t rook_masks[64];
const uint64_t rook_magics[64] = {
    0xa8002c000108020ULL,
    0x6c00049b0002001ULL,
    0x100200010090040ULL,
    0x2480041000800801ULL,
    0x280028004000800ULL,
    0x900410008040022ULL,
    0x280020001001080ULL,
    0x2880002041000080ULL,
    0xa000800080400034ULL,
    0x4808020004000ULL,
    0x2290802004801000ULL,
    0x411000d00100020ULL,
    0x402800800040080ULL,
    0xb000401004208ULL,
    0x2409000100040200ULL,
    0x1002100004082ULL,
    0x22878001e24000ULL,
    0x1090810021004010ULL,
    0x801030040200012ULL,
    0x500808008001000ULL,
    0xa08018014000880ULL,
    0x8000808004000200ULL,
    0x201008080010200ULL,
    0x801020000441091ULL,
    0x800080204005ULL,
    0x1040200040100048ULL,
    0x120200402082ULL,
    0xd14880480100080ULL,
    0x12040280080080ULL,
    0x100040080020080ULL,
    0x9020010080800200ULL,
    0x813241200148449ULL,
    0x491604001800080ULL,
    0x100401000402001ULL,
    0x4820010021001040ULL,
    0x400402202000812ULL,
    0x209009005000802ULL,
    0x810800601800400ULL,
    0x4301083214000150ULL,
    0x204026458e001401ULL,
    0x40204000808000ULL,
    0x8001008040010020ULL,
    0x8410820820420010ULL,
    0x1003001000090020ULL,
    0x804040008008080ULL,
    0x12000810020004ULL,
    0x1000100200040208ULL,
    0x430000a044020001ULL,
    0x280009023410300ULL,
    0xe0100040002240ULL,
    0x200100401700ULL,
    0x2244100408008080ULL,
    0x8000400801980ULL,
    0x2000810040200ULL,
    0x8010100228810400ULL,
    0x2000009044210200ULL,
    0x4080008040102101ULL,
    0x40002080411d01ULL,
    0x2005524060000901ULL,
    0x502001008400422ULL,
    0x489a000810200402ULL,
    0x1004400080a13ULL,
    0x4000011008020084ULL,
    0x26002114058042ULL,
};
const uint64_t bishop_magics[64] = {
    0x89a1121896040240ULL,
    0x2004844802002010ULL,
    0x2068080051921000ULL,
    0x62880a0220200808ULL,
    0x4042004000000ULL,
    0x100822020200011ULL,
    0xc00444222012000aULL,
    0x28808801216001ULL,
    0x400492088408100ULL,
    0x201c401040c0084ULL,
    0x840800910a0010ULL,
    0x82080240060ULL,
    0x2000840504006000ULL,
    0x30010c4108405004ULL,
    0x1008005410080802ULL,
    0x8144042209100900ULL,
    0x208081020014400ULL,
    0x4800201208ca00ULL,
    0xf18140408012008ULL,
    0x1004002802102001ULL,
    0x841000820080811ULL,
    0x40200200a42008ULL,
    0x800054042000ULL,
    0x88010400410c9000ULL,
    0x520040470104290ULL,
    0x1004040051500081ULL,
    0x2002081833080021ULL,
    0x400c00c010142ULL,
    0x941408200c002000ULL,
    0x658810000806011ULL,
    0x188071040440a00ULL,
    0x4800404002011c00ULL,
    0x104442040404200ULL,
    0x511080202091021ULL,
    0x4022401120400ULL,
    0x80c0040400080120ULL,
    0x8040010040820802ULL,
    0x480810700020090ULL,
    0x102008e00040242ULL,
    0x809005202050100ULL,
    0x8002024220104080ULL,
    0x431008804142000ULL,
    0x19001802081400ULL,
    0x200014208040080ULL,
    0x3308082008200100ULL,
    0x41010500040c020ULL,
    0x4012020c04210308ULL,
    0x208220a202004080ULL,
    0x111040120082000ULL,
    0x6803040141280a00ULL,
    0x2101004202410000ULL,
    0x8200000041108022ULL,
    0x21082088000ULL,
    0x2410204010040ULL,
    0x40100400809000ULL,
    0x822088220820214ULL,
    0x40808090012004ULL,
    0x910224040218c9ULL,
    0x402814422015008ULL,
    0x90014004842410ULL,
    0x1000042304105ULL,
    0x10008830412a00ULL,
    0x2520081090008908ULL,
    0x40102000a0a60140ULL,
};
uint64_t bishop_attacks[64][512];
uint64_t rook_attacks[64][4096];
void init_sliders_attacks(int is_bishop)
{
    // loop over 64 board squares
    for (int square = 0; square < 64; square++)
    {
        // init bishop & rook masks
        bishop_masks[square] = mask_bishop_attacks(square);
        rook_masks[square] = mask_rook_attacks(square);

        // init current mask
        uint64_t mask = is_bishop ? mask_bishop_attacks(square) : mask_rook_attacks(square);

        // count attack mask bits
        int bit_count = count_bits(mask);

        // occupancy variations count
        int occupancy_variations = 1 << bit_count;

        // loop over occupancy variations
        for (int count = 0; count < occupancy_variations; count++)
        {
            // bishop
            if (is_bishop)
            {
                // init occupancies, magic index & attacks
                uint64_t occupancy = set_occupancy(count, bit_count, mask);
                uint64_t magic_index = occupancy * bishop_magics[square] >> 64 - bishop_rellevant_bits[square];
                bishop_attacks[square][magic_index] = bishop_attacks_on_the_fly(square, occupancy);
            }

            // rook
            else
            {
                // init occupancies, magic index & attacks
                uint64_t occupancy = set_occupancy(count, bit_count, mask);
                uint64_t magic_index = occupancy * rook_magics[square] >> 64 - rook_rellevant_bits[square];
                rook_attacks[square][magic_index] = rook_attacks_on_the_fly(square, occupancy);
            }
        }
    }
}
uint64_t get_bishop_attacks(int square, uint64_t occupancy) {

    // calculate magic index
    occupancy &= bishop_masks[square];
    occupancy *= bishop_magics[square];
    occupancy >>= 64 - bishop_rellevant_bits[square];

    // return rellevant attacks
    return bishop_attacks[square][occupancy];

}
uint64_t get_rook_attacks(int square, uint64_t occupancy) {

    // calculate magic index
    occupancy &= rook_masks[square];
    occupancy *= rook_magics[square];
    occupancy >>= 64 - rook_rellevant_bits[square];

    // return rellevant attacks
    return rook_attacks[square][occupancy];
}

//end of mostly copied code

const int BOARD_WIDTH = 8;
const int BOARD_HEIGHT = 8;

const uint64_t EMPTY = 0;
const uint64_t PAWNS = 0xFF00;
const uint64_t KNIGHTS = 0x42;
const uint64_t BISHOPS = 0x24;
const uint64_t KING = 0x8;
const uint64_t QUEEN = 0x10;
const uint64_t ROOKS = 0x81;
const int CASTLING = 0xF;
const int EN_PASSANT = 0;
const uint64_t trim_left = 0x8080808080808080;
const uint64_t trim_right = 0x101010101010101;
const int both_king_locations = e1 * 100 + e8;
const int max_saved_board_n = 100;
const int DEPTH = 8;
int HOW_MANY_THREADS_AT_THE_SAME_TIME;
const int QUESCENCE_SEARCH_DEPTH = 10;

//EVALUATION TEMPS
const int EarlyGameCenterControlForPawnsW[64] = {
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0, 10, 10, 10, 10,  0,  0,
    0,  0, 10, 40, 40, 10,  0,  0,
    0,  0,  0, 40, 40,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0
};
const int EarlyGameCenterControlForPawnsB[64] = {
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0, 40, 40,  0,  0,  0,
    0,  0, 10, 40, 40, 10,  0,  0,
    0,  0, 10, 10, 10, 10,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0
};
const int EarlyGameHideKingInTheCorner[64] = {
   25, 15,  0,  0,  0,  0, 0,  30,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
   25, 15,  0,  0,  0,  0, 0,  30
};
const int EarlyGamemoveTheKnightInTheCenter[64]{
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0, 10, 10, 10, 10,  0,  0,
    0, 10, 20,  0,  0, 20, 10,  0,
    0, 10,  0, 20, 20,  0, 10,  0,
    0, 10,  0, 20, 20,  0, 10,  0,
    0, 10, 20,  0,  0, 20, 10,  0,
    0,  0, 10, 10, 10, 10,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0
};
const int EarlyGameQueenCenterControl[64] = {
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0, 30, 30,  0,  0,  0,
    0,  0,  0, 30, 30,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
};
const int EarlyGameWiderCenterControl[64] = {
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0, 10, 10, 10, 10,  0,  0,
    0,  0, 10,  0,  0, 10,  0,  0,
    0,  0, 10,  0,  0, 10,  0,  0,
    0,  0, 10, 10, 10, 10,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
};
const double general_go_forwardW[64] = {
    -1.5, -1.5, -1.5, -1.5, -1.5, -1.5, -1.5, -1.5,
     1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5,
       3,    3,    3,    3,    3,    3,    3,    3,
     4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,
       6,    6,    6,    6,    6,    6,    6,    6,
     7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5,  7.5,
       6,    6,    6,    6,    6,    6,    6,    6,
       3,    3,    3,    3,    3,    3,    3,    3,

};
const double general_go_center[64] = {

};


const uint64_t level_1_square = 0xFF818181818181FF;
const uint64_t level_2_square = 0x7E424242427E00;
const uint64_t level_3_square = 0x3C24243C0000;
const uint64_t level_4_square = 0x1818000000;

const uint64_t checkerboard_pattern = 0x55AA55AA55AA55AA;//starting with empty in the bottom

int bonus_for_further_passers[64] = {
       1,    1,    1,    1,    1,    1,    1,    1,
    1.5,   1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5,
    1.5,   1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5,
    1.5,   1.5,  1.5,  1.5,  1.5,  1.5,  1.5,  1.5,
    1.75, 1.75, 1.75, 1.75, 1.75, 1.75, 1.75, 1.75,
    2.18, 2.18, 2.18, 2.18, 2.18, 2.18, 2.18, 2.18,
    2.73, 2.73, 2.73, 2.73, 2.73, 2.73, 2.73, 2.73,
    3.41, 3.41, 3.41, 3.41, 3.41, 3.41, 3.41, 3.41,
};
int ENDGAMEkingcentercontrol[64] = {
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  5,  5,  5,  5,  0,  0,
    0,  0,  5, 20, 20,  5,  0,  0,
    0,  0,  5, 20, 20,  5,  0,  0,
    0,  0,  5,  5,  5,  5,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0
};
//EVALUATION TEMPS END


const int pawn = 100;
const int pawn_value = 1 * pawn;
const int bishop_value = 3 * pawn;
const int knight_value = 3 * pawn;
const int rook_value = 5 * pawn;
const int queen_value = 9 * pawn;
const int king_value = 0 * pawn;//worthless piece of shit
const std::string line = "---------------------------------------------------------------------------------------------------------------------\n";

int moveCount = 0;

enum { p, b, n, r, q, k };


std::vector<std::string> split(const std::string line, char split_symbol);

unsigned int find_first_set_bit(uint64_t x);
std::vector<std::thread> threads;
const std::string normal_notation[65] = {
    "h1","g1","f1","e1","d1","c1","b1","a1",
    "h2","g2","f2","e2","d2","c2","b2","a2",
    "h3","g3","f3","e3","d3","c3","b3","a3",
    "h4","g4","f4","e4","d4","c4","b4","a4",
    "h5","g5","f5","e5","d5","c5","b5","a5",
    "h6","g6","f6","e6","d6","c6","b6","a6",
    "h7","g7","f7","e7","d7","c7","b7","a7",
    "h8","g8","f8","e8","d8","c8","b8","a8","( ͡° ͜ʖ ͡°)"
};
void read_precomputed_moves(std::unordered_map<std::string, std::string>& precomputed_moves, const std::string file_name) {
    std::ifstream input_file(file_name);
    if (input_file.is_open()) {
        std::string line;

        while (std::getline(input_file, line)) {
            if (line[0] != '#' && line != "") {
                std::vector<std::string> split_line = split(line, ';');
                precomputed_moves[split_line[0]] = split_line[1];
            }
        }

        input_file.close();
    }
    else {
        std::cout << "ZE \"" << file_name << "\" FILE is MISSING\n";
    }
}
std::vector<std::string> split(const std::string line, char split_symbol) {
    int i = 0;
    std::vector<std::string> words;
    std::string word = "";
    while (i != line.length()) {
        if (line[i] != split_symbol)
            word += line[i];
        else if (word != "") { words.push_back(word); word = ""; }
        i++;
    }
    if (word[word.length() - 1] != split_symbol && word != "")words.push_back(word);
    return words;
}
struct bitboards
{
    uint64_t pawns = 0;
    uint64_t knights = 0;
    uint64_t bishops = 0;
    uint64_t king = 0;
    uint64_t queen = 0;
    uint64_t rooks = 0;
};
struct chessboard
{
    bitboards white;
    bitboards black;
    int quescent_search_depth_remaining = QUESCENCE_SEARCH_DEPTH;
    int castling = 0;
    int en_passant = 0;//where en passant located
    int king_squares = 0;//where king are located
    bool keep_en_passant = 0;//keep en passant for 1 move
};
struct cheese_boards {
    chessboard board[max_saved_board_n];
    int eval[max_saved_board_n];
    int n = 0;
};
cheese_boards ALL_LAYER_BOARDS;
bool are_chessboards_equal(chessboard a, chessboard b) {
    return a.en_passant == b.en_passant && a.white.bishops == b.white.bishops && a.white.pawns == b.white.pawns && a.white.knights == b.white.knights && a.white.king == b.white.king &&
        a.white.queen == b.white.queen && a.white.rooks == b.white.rooks && a.castling == b.castling && a.keep_en_passant == b.keep_en_passant && a.king_squares == b.king_squares &&
        a.black.bishops == b.black.bishops && a.black.pawns == b.black.pawns && a.black.knights == b.black.knights && a.black.king == b.black.king &&
        a.black.queen == b.black.queen && a.black.rooks == b.black.rooks;
}
std::vector<chessboard> check_for_three_fold_repetition;
bool has_position_occured_two_times(chessboard position) {
    if (check_for_three_fold_repetition.size() < 3) return false;
    bool occured = false;
    //std::cout << "searching for:/" << position << "/\n";
    for (const chessboard& pos : check_for_three_fold_repetition) {
        //std::cout << "/" << pos << "/\n";
        if (are_chessboards_equal(pos, position)) {
            if (occured)return true;
            else occured = true;
        }
    }
    return false;
}

int get_attacked_pieces_value(chessboard BOARD, uint64_t attacked, bool white_attacking);
chessboard initialize_chessboard() {
    chessboard board;
    board.white.pawns = PAWNS;
    board.white.knights = KNIGHTS;
    board.white.bishops = BISHOPS;
    board.white.king = KING;
    board.white.queen = QUEEN;
    board.white.rooks = ROOKS;
    board.black.pawns = PAWNS << 5 * 8;
    board.black.knights = KNIGHTS << 7 * 8;
    board.black.bishops = BISHOPS << 7 * 8;
    board.black.king = KING << 7 * 8;
    board.black.queen = QUEEN << 7 * 8;
    board.black.rooks = ROOKS << 7 * 8;
    board.castling = CASTLING;
    board.en_passant = EN_PASSANT;
    board.keep_en_passant = EN_PASSANT;
    board.king_squares = both_king_locations;
    return board;
}
uint64_t get_pawn_moves(uint64_t occupancy, int square, bool is_white, uint64_t opponent_occupancy) {
    uint64_t pawn_moves = 0, pawn = 0;
    set_bit(pawn, square);
    if (is_white) {
        pawn_moves = (~occupancy & (pawn << BOARD_WIDTH));//move one forward
        pawn_moves |= ((pawn_moves & (PAWNS << BOARD_WIDTH)) << BOARD_WIDTH) & ~occupancy;//move 2 forward
        pawn_moves |= ((pawn & ~trim_left) << (BOARD_WIDTH + 1)) & opponent_occupancy;
        pawn_moves |= ((pawn & ~trim_right) << (BOARD_WIDTH - 1)) & opponent_occupancy;
    }
    else {//reverse
        pawn_moves = (~occupancy & (pawn >> BOARD_WIDTH));
        pawn_moves |= ((pawn_moves & (PAWNS << (4 * BOARD_WIDTH))) >> BOARD_WIDTH) & ~occupancy;
        pawn_moves |= ((pawn & ~trim_right) >> (BOARD_WIDTH + 1)) & opponent_occupancy;
        pawn_moves |= ((pawn & ~trim_left) >> (BOARD_WIDTH - 1)) & opponent_occupancy;
    }
    return pawn_moves;
}
uint64_t get_pawn_attacks(int square, bool white) {
    uint64_t pawn_attacks = 0, temp = 0;
    set_bit(temp, square);
    if (white) {
        pawn_attacks |= (temp & ~trim_right) << 7;
        pawn_attacks |= (temp & ~trim_left) << 9;
    }
    else {
        pawn_attacks |= (temp & ~trim_right) >> 7;
        pawn_attacks |= (temp & ~trim_left) >> 9;
    }
    return pawn_attacks;
}
uint64_t get_all_pawn_attacks(uint64_t pawns, bool is_white) {
    uint64_t pawn_attacks = 0;
    if (is_white) {
        pawn_attacks = ((pawns & ~trim_left) << BOARD_WIDTH + 1);
        pawn_attacks |= ((pawns & ~trim_right) << BOARD_WIDTH - 1);
    }
    else {//reverse
        pawn_attacks = ((pawns & ~trim_right) >> BOARD_WIDTH + 1);
        pawn_attacks |= ((pawns & ~trim_left) >> BOARD_WIDTH - 1);
    }
    return pawn_attacks;
}
uint64_t get_all_pawn_moves(uint64_t pawns, uint64_t occupancy, bool white) {
    uint64_t pawn_moves = 0;
    if (white) {
        pawn_moves = (~occupancy & (pawns << BOARD_WIDTH));//move one forward
        pawn_moves |= ((pawn_moves & (PAWNS << BOARD_WIDTH)) << BOARD_WIDTH) & ~occupancy;//move 2 forward
    }
    else {//reverse
        pawn_moves = (~occupancy & (pawns >> BOARD_WIDTH));
        pawn_moves |= ((pawn_moves & (PAWNS << (4 * BOARD_WIDTH))) >> BOARD_WIDTH) & ~occupancy;
    }
    return pawn_moves;
}
uint64_t get_knight_attacks(int square) {
    return knight_magics[square];
}
uint64_t get_king_attacks(int square) {
    return king_magics[square];
}
uint64_t get_occupancy(bitboards a) {
    return a.pawns | a.knights | a.bishops | a.king | a.queen | a.rooks;
}
uint64_t get_occupancy(chessboard a) {
    return get_occupancy(a.black) | get_occupancy(a.white);
}
bool king_in_check(chessboard BOARD, bool white);
uint64_t get_queen_attacks(int square, uint64_t occupancy) {
    return get_rook_attacks(square, occupancy) | get_bishop_attacks(square, occupancy);
}
int get_xray_attacks(chessboard BOARD, uint64_t attack_rays, bool white, char piece, int square) {
    uint64_t all_piece_occupancy = get_occupancy(BOARD), attacked_opponent_pieces;
    int power = 1, returnvalue = 0;
    if (white) {
        while ((attack_rays & all_piece_occupancy) != 0) {
            if (piece == 'q') {
                all_piece_occupancy &= ~get_queen_attacks(square, all_piece_occupancy);
            }
            else if (piece == 'b') {
                all_piece_occupancy &= ~get_bishop_attacks(square, all_piece_occupancy);
            }
            else if (piece == 'r') {
                all_piece_occupancy &= ~get_rook_attacks(square, all_piece_occupancy);
            }
            attacked_opponent_pieces = get_occupancy(BOARD.black) & get_queen_attacks(square, all_piece_occupancy);
            returnvalue += get_attacked_pieces_value(BOARD, attacked_opponent_pieces, true) * pow(0.5, power);
            if ((attacked_opponent_pieces & BOARD.black.king) != 0) returnvalue += 18 * pow(0.5, power);
            power++;
        }
    }
    else {
        while ((attack_rays & all_piece_occupancy) != 0) {
            if (piece == 'q') {
                all_piece_occupancy &= ~get_queen_attacks(square, all_piece_occupancy);
            }
            else if (piece == 'b') {
                all_piece_occupancy &= ~get_bishop_attacks(square, all_piece_occupancy);
            }
            else if (piece == 'r') {
                all_piece_occupancy &= ~get_rook_attacks(square, all_piece_occupancy);
            }
            attacked_opponent_pieces = get_occupancy(BOARD.white) & get_queen_attacks(square, all_piece_occupancy);
            returnvalue += get_attacked_pieces_value(BOARD, attacked_opponent_pieces, false) * pow(0.5, power);
            if ((attacked_opponent_pieces & BOARD.white.king) != 0) returnvalue += 18 * pow(0.5, power);
            power++;
        }
    }
    return returnvalue;
}
int get_attacked_pieces_value(chessboard BOARD, uint64_t attacked, bool white_attacking) {
    int temp_nr, return_value = 0;
    if (white_attacking) {
        while (attacked != 0) {
            temp_nr = find_first_set_bit(attacked);
            if (get_bit(BOARD.black.bishops, temp_nr) != 0) return_value += 30;
            else if (get_bit(BOARD.black.pawns, temp_nr) != 0) return_value += 10;
            else if (get_bit(BOARD.black.knights, temp_nr) != 0) return_value += 30;
            else if (get_bit(BOARD.black.queen, temp_nr) != 0) return_value += 90;
            else if (get_bit(BOARD.black.rooks, temp_nr) != 0) return_value += 45;
            pop_bit(attacked, temp_nr);
        }
    }
    else {
        while (attacked != 0) {
            temp_nr = find_first_set_bit(attacked);
            if (get_bit(BOARD.white.bishops, temp_nr) != 0) return_value += 30;
            else if (get_bit(BOARD.white.pawns, temp_nr) != 0) return_value += 10;
            else if (get_bit(BOARD.white.knights, temp_nr) != 0) return_value += 30;
            else if (get_bit(BOARD.white.queen, temp_nr) != 0) return_value += 90;
            else if (get_bit(BOARD.white.rooks, temp_nr) != 0) return_value += 45;
            pop_bit(attacked, temp_nr);
        }
    }
    return return_value;
}
chessboard initialize_chessboard(std::string FenCode, bool& White, int& time) {
    chessboard board;
    int g = 0, i = 0, j = 0;
    char temp;
    while (FenCode[g] != ' ') {//main board
        temp = FenCode[g];
        if (FenCode[g] == '/') { i++;j = 0; }
        else if (temp < '9') {
            j += temp - '0';
        }
        else {
            if (temp == 'R')set_bit(board.white.rooks, 63 - i * 8 - j);
            else if (temp == 'N')set_bit(board.white.knights, 63 - i * 8 - j);
            else if (temp == 'Q')set_bit(board.white.queen, 63 - i * 8 - j);
            else if (temp == 'B')set_bit(board.white.bishops, 63 - i * 8 - j);
            else if (temp == 'K') { set_bit(board.white.king, 63 - i * 8 - j);board.king_squares += (63 - i * 8 - j) * 100; }
            else if (temp == 'P')set_bit(board.white.pawns, 63 - i * 8 - j);
            else if (temp == 'r')set_bit(board.black.rooks, 63 - i * 8 - j);
            else if (temp == 'n')set_bit(board.black.knights, 63 - i * 8 - j);
            else if (temp == 'b')set_bit(board.black.bishops, 63 - i * 8 - j);
            else if (temp == 'k') { set_bit(board.black.king, 63 - i * 8 - j);board.king_squares += 63 - i * 8 - j; }
            else if (temp == 'p')set_bit(board.black.pawns, 63 - i * 8 - j);
            else if (temp == 'q')set_bit(board.black.queen, 63 - i * 8 - j);
            j++;
        }
        g++;
    }
    if (FenCode[++g] == 'w')White = true;//kas eina
    else White = false;
    g += 2;
    while (FenCode[g] != ' ') {//castling
        if (FenCode[g] == '-') {
            g++;
            break;
        }
        else if (FenCode[g] == 'K')board.castling += 4;
        else if (FenCode[g] == 'Q')board.castling += 8;
        else if (FenCode[g] == 'k')board.castling += 1;
        else if (FenCode[g] == 'q')board.castling += 2;
        g++;
    }
    g++;
    if (FenCode[g] != '-') {//a peasant
        board.keep_en_passant = 1;board.en_passant = int(FenCode[g] - 'a') + (8 - int(FenCode[g + 1] - '0')) * 8;
        g += 3;
    }
    else g += 2;
    g += 4;
    std::string timeString;
    if (White) while (FenCode[g] != ' ')
    {
        timeString += FenCode[g];
        g++;
    }
    else {
        while (FenCode[g] != ' ')g++;
        g++;
        while (g < FenCode.length())
        {
            timeString += FenCode[g];
            g++;
        }
    }
    return board;
}
void sort_positions(cheese_boards& BOARDS, bool white) {
    chessboard temp_board;
    int temp_eval, tempI;
    for (int i = 0; i < BOARDS.n; i++) {
        tempI = i;
        temp_eval = BOARDS.eval[i];
        for (int j = i + 1; j < BOARDS.n; j++) {
            if (white) {
                if (BOARDS.eval[j] > temp_eval) {
                    tempI = j;
                    temp_eval = BOARDS.eval[j];
                }
            }
            else {
                if (BOARDS.eval[j] < temp_eval) {
                    tempI = j;
                    temp_eval = BOARDS.eval[j];
                }
            }
        }
        if (tempI != i) {
            temp_board = BOARDS.board[i];
            BOARDS.board[i] = BOARDS.board[tempI];
            BOARDS.board[tempI] = temp_board;
            BOARDS.eval[tempI] = ALL_LAYER_BOARDS.eval[i];
            BOARDS.eval[i] = temp_eval;
        }
    }
}
unsigned int find_first_set_bit(uint64_t x)
{
    static const int debruijn64[64] = {
        0, 1, 48, 2, 57, 49, 28, 3, 61, 58, 50, 42, 38, 29, 17, 4,
        62, 55, 59, 36, 53, 51, 43, 22, 45, 39, 33, 30, 24, 18, 12, 5,
        63, 47, 56, 27, 60, 41, 37, 16, 54, 35, 52, 21, 44, 32, 23, 11,
        46, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6
    };
    return debruijn64[((uint64_t)((x & (-1 * x)) * 0x03f79d71b4cb0a89)) >> 58];
}
int Count_bits(uint64_t bitboard) {
    //Hamming weight algorithm or something
    bitboard = bitboard - ((bitboard >> 1) & 0x5555555555555555ULL);
    bitboard = (bitboard & 0x3333333333333333ULL) + ((bitboard >> 2) & 0x3333333333333333ULL);
    bitboard = (bitboard + (bitboard >> 4)) & 0x0f0f0f0f0f0f0f0fULL;
    bitboard = bitboard + (bitboard >> 8);
    bitboard = bitboard + (bitboard >> 16);
    bitboard = bitboard + (bitboard >> 32);
    return static_cast<int>(bitboard & 0x7f);
}
void print_board(chessboard BOARD) {
    std::cout << "\n";
    uint64_t pointer = 0x8000000000000000ULL, occupied = get_occupancy(BOARD), black = get_occupancy(BOARD.black), white = get_occupancy(BOARD.white);
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8;j++) {
            if ((occupied & pointer) != 0) {
                if ((white & pointer) != 0) {
                    if ((BOARD.white.bishops & pointer) != 0)std::cout << "B ";
                    else if ((BOARD.white.pawns & pointer) != 0)std::cout << "P ";
                    else if ((BOARD.white.knights & pointer) != 0)std::cout << "N ";
                    else if ((BOARD.white.queen & pointer) != 0)std::cout << "Q ";
                    else if ((BOARD.white.rooks & pointer) != 0)std::cout << "R ";
                    else if ((BOARD.white.king & pointer) != 0)std::cout << "K ";
                }
                else {
                    if ((BOARD.black.bishops & pointer) != 0)std::cout << "b ";
                    else if ((BOARD.black.pawns & pointer) != 0)std::cout << "p ";
                    else if ((BOARD.black.knights & pointer) != 0)std::cout << "n ";
                    else if ((BOARD.black.queen & pointer) != 0)std::cout << "q ";
                    else if ((BOARD.black.rooks & pointer) != 0)std::cout << "r ";
                    else if ((BOARD.black.king & pointer) != 0)std::cout << "k ";
                }
            }
            else
                std::cout << "- ";
            pointer >>= 1;
        }
        std::cout << "\n";
    }
    std::cout << "\n";
}
std::string change_to_human_language(uint64_t color_occupancy_before_move, uint64_t color_occupancy_after_move) {
    if (Count_bits((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move) == 1)
        return normal_notation[find_first_set_bit((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move)] + normal_notation[find_first_set_bit((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_before_move)];
    else {//castling
        uint64_t check_square_for_occupation = 0;
        set_bit(check_square_for_occupation, e1);
        if ((check_square_for_occupation & ((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move)) != 0) {
            check_square_for_occupation = 0;
            set_bit(check_square_for_occupation, a1);
            if ((check_square_for_occupation & ((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move)) != 0) {
                return "e1c1";
            }
            check_square_for_occupation = 0;
            set_bit(check_square_for_occupation, h1);
            if ((check_square_for_occupation & ((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move)) != 0) {
                return "e1g1";
            }
        }
        check_square_for_occupation = 0;
        set_bit(check_square_for_occupation, e8);
        if ((check_square_for_occupation & ((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move)) != 0) {
            check_square_for_occupation = 0;
            set_bit(check_square_for_occupation, a8);
            if ((check_square_for_occupation & ((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move)) != 0) {
                return "e8c8";
            }
            check_square_for_occupation = 0;
            set_bit(check_square_for_occupation, h8);
            if ((check_square_for_occupation & ((color_occupancy_before_move ^ color_occupancy_after_move) & ~color_occupancy_after_move)) != 0) {
                return "e8g8";
            }
        }
    }
    std::cout << "error here";
    print_bitboard(color_occupancy_before_move);
    print_bitboard(color_occupancy_after_move);
    return "cry about it";
}
void restore_opponents_piece(chessboard& BOARD, int square, bool white, int what_to_restore) {
    if (white) {
        if (what_to_restore == p)set_bit(BOARD.black.pawns, square);
        else if (what_to_restore == r)set_bit(BOARD.black.rooks, square);
        else if (what_to_restore == q)set_bit(BOARD.black.queen, square);
        else if (what_to_restore == b)set_bit(BOARD.black.bishops, square);
        else if (what_to_restore == n)set_bit(BOARD.black.knights, square);
    }
    else {
        if (what_to_restore == p)set_bit(BOARD.white.pawns, square);
        else if (what_to_restore == r)set_bit(BOARD.white.rooks, square);
        else if (what_to_restore == q)set_bit(BOARD.white.queen, square);
        else if (what_to_restore == b)set_bit(BOARD.white.bishops, square);
        else if (what_to_restore == n)set_bit(BOARD.white.knights, square);
    }
}
void delete_opponents_piece(chessboard& BOARD, int square, bool white, int& what_to_restore) {
    uint64_t capturing = 0;
    set_bit(capturing, square);
    if (white) {
        if ((BOARD.black.bishops & capturing) != 0) { what_to_restore = b; BOARD.black.bishops &= ~capturing; }
        else if ((BOARD.black.pawns & capturing) != 0) { what_to_restore = p; BOARD.black.pawns &= ~capturing; }
        else if ((BOARD.black.knights & capturing) != 0) { what_to_restore = n; BOARD.black.knights &= ~capturing; }
        else if ((BOARD.black.queen & capturing) != 0) { what_to_restore = q; BOARD.black.queen &= ~capturing; }
        else if ((BOARD.black.rooks & capturing) != 0) {
            what_to_restore = r; BOARD.black.rooks &= ~capturing;
            if (square == a1 && (BOARD.castling & 8) != 0)BOARD.castling &= 8;
            if (square == h1 && (BOARD.castling & 4) != 0)BOARD.castling &= 4;
        }
    }
    else {
        if ((BOARD.white.bishops & capturing) != 0) { what_to_restore = b; BOARD.white.bishops &= ~capturing; }
        else if ((BOARD.white.knights & capturing) != 0) { what_to_restore = n; BOARD.white.knights &= ~capturing; }
        else if ((BOARD.white.queen & capturing) != 0) { what_to_restore = q; BOARD.white.queen &= ~capturing; }
        else if ((BOARD.white.pawns & capturing) != 0) { what_to_restore = p; BOARD.white.pawns &= ~capturing; }
        else if ((BOARD.white.rooks & capturing) != 0) {
            what_to_restore = r; BOARD.white.rooks &= ~capturing;
            if (square == a8 && (BOARD.castling & 2) != 0)BOARD.castling &= 2;
            if (square == h8 && (BOARD.castling & 1) != 0)BOARD.castling &= 1;
        }
    }
}
int quickEVAL(chessboard BOARD) {
    int eval = 0, returnEval = 0;
    if (BOARD.white.pawns != 0) eval += Count_bits(BOARD.white.pawns) * pawn_value;
    if (BOARD.white.queen != 0) eval += Count_bits(BOARD.white.pawns) * queen_value;
    if (BOARD.white.rooks != 0) eval += Count_bits(BOARD.white.pawns) * rook_value;
    if (BOARD.white.knights != 0) eval += Count_bits(BOARD.white.pawns) * knight_value;
    if (BOARD.white.bishops != 0) eval += Count_bits(BOARD.white.pawns) * bishop_value;

    returnEval += eval;
    eval = 0;

    if (BOARD.black.pawns != 0) eval += Count_bits(BOARD.black.pawns) * pawn_value;
    if (BOARD.black.queen != 0) eval += Count_bits(BOARD.black.pawns) * queen_value;
    if (BOARD.black.rooks != 0) eval += Count_bits(BOARD.black.pawns) * rook_value;
    if (BOARD.black.knights != 0) eval += Count_bits(BOARD.black.pawns) * knight_value;
    if (BOARD.black.bishops != 0) eval += Count_bits(BOARD.black.pawns) * bishop_value;
    return returnEval + eval;
}
int EVAL(chessboard BOARD, int depth, int alpha, int beta) {
    uint64_t white_occupancy = get_occupancy(BOARD.white), all_occupancy = get_occupancy(BOARD), black_occupancy = all_occupancy ^ white_occupancy, temp_something,
        control = 0, passed_pawns = 0, doubled_pawns = 0, isolated_pawns = 0, backwards_pawns = 0, semi_backwards_pawns = 0, backwards_fated_pawns = 0, empty_board = 0;
    int eval = 0, finalEval = 0;
    int temp_n, temp_nr, move_count = DEPTH - depth + 1 + moveCount, n_of_pawns = Count_bits(BOARD.white.pawns) + Count_bits(BOARD.black.pawns), temp_control_square_worth = 10, opponent_pawn_attacks = 0;
    double add_more_detailed_eval = 0;
    int allPieces_n = Count_bits(get_occupancy(BOARD)), quick_eval;

    /*if ((alpha != -100000 && ((quick_eval = quickEVAL(BOARD)) > alpha + 920)) || (beta != 100000 && ((quick_eval = quickEVAL(BOARD)) < beta - 920)) && !king_in_check(BOARD, 1) && !king_in_check(BOARD, 0))
        return quick_eval;*/

    double rookValue, queenValue, bishopValue, knightValue;
    if (n_of_pawns < 5) {//open position
        rookValue = 1.1;
        queenValue = 1.3;
        bishopValue = 1.2;
        knightValue = 0.85;
    }
    else if (n_of_pawns < 9) {//semi-open position
        rookValue = 1.1;
        queenValue = 1.2;
        bishopValue = 1.15;
        knightValue = 0.90;
    }
    else if (n_of_pawns < 12) {//semi-closed position
        rookValue = 0.9;
        queenValue = 0.95;
        bishopValue = 1.05;
        knightValue = 1.1;
    }
    else {//closed positions
        rookValue = 0.85;
        queenValue = 0.9;
        bishopValue = 1;
        knightValue = 1.1;
    }

    int ERoMoE = 0;
    if (move_count < 16)
        ERoMoE = -1;
    else if (move_count > 15 && allPieces_n > 20)
        ERoMoE = 0;
    else
        ERoMoE = 1;

    uint64_t temp_pieces;
    temp_pieces = white_occupancy;

    if (ERoMoE == -1) {
        double temp_eval_for_oppening0 = 0, temp_eval_for_oppening1 = 0, temp_eval_for_oppening2 = 0;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            temp_eval_for_oppening1 += general_go_forwardW[temp_nr];
            if (get_bit(level_1_square, temp_nr) != 0)temp_eval_for_oppening2 += 2.5;
            else if (get_bit(level_2_square, temp_nr) != 0)temp_eval_for_oppening2 += 5;
            else if (get_bit(level_3_square, temp_nr) != 0)temp_eval_for_oppening2 += 7.5;
            else if (get_bit(level_4_square, temp_nr) != 0)temp_eval_for_oppening2 += 10;
            pop_bit(temp_pieces, temp_nr);
        }
        add_more_detailed_eval += temp_eval_for_oppening1 + temp_eval_for_oppening1 + (temp_eval_for_oppening1 + temp_eval_for_oppening2) / 2;
    }



    if ((temp_n = Count_bits(BOARD.white.pawns)) != 0) {
        temp_pieces = BOARD.white.pawns;
        eval += temp_n * pawn_value;
        if (ERoMoE > -1) {
            eval += (Count_bits(get_all_pawn_attacks(BOARD.white.pawns, true)) + Count_bits(get_all_pawn_moves(BOARD.white.pawns, all_occupancy, true))) * 5;
            control |= get_all_pawn_attacks(BOARD.white.pawns, true);
        }
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
                eval += EarlyGameCenterControlForPawnsW[temp_nr];
            }
            else if (ERoMoE > -1) {

                if ((BOARD.black.pawns & (trim_left >> temp_nr % 8)) == 0) { set_bit(passed_pawns, temp_nr); }

                pop_bit(BOARD.white.pawns, temp_nr);
                if ((BOARD.white.pawns & (trim_left >> temp_nr % 8)) != 0) { set_bit(doubled_pawns, temp_nr); }
                set_bit(BOARD.white.pawns, temp_nr);

                if ((BOARD.white.pawns & get_king_attacks(temp_nr)) == 0) { set_bit(isolated_pawns, temp_nr); }

                if (get_bit(get_all_pawn_attacks(BOARD.black.pawns, false), temp_nr + 8) != 0) {
                    if (get_bit(get_all_pawn_attacks(BOARD.white.pawns, true), temp_nr + 8) != 0)
                        set_bit(semi_backwards_pawns, temp_nr);
                    else {
                        if (Count_bits(BOARD.black.pawns & get_pawn_attacks(temp_nr + 8, true)) == 2)
                            set_bit(backwards_fated_pawns, temp_nr);
                        else {
                            set_bit(backwards_pawns, temp_nr);
                        }
                    }
                }
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.white.knights)) != 0) {
        eval += temp_n * knight_value * knightValue;
        temp_pieces = BOARD.white.knights;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
                eval += EarlyGamemoveTheKnightInTheCenter[temp_nr];
            }
            else if (ERoMoE > -1) {
                control |= get_knight_attacks(temp_nr);
                temp_something = get_knight_attacks(temp_nr) & ~all_occupancy;
                temp_control_square_worth = 15;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something) / 2 * 3;
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.white.bishops)) != 0) {
        eval += temp_n * bishop_value * bishopValue;
        temp_pieces = BOARD.white.bishops;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
            }
            else if (ERoMoE > -1) {
                control |= get_bishop_attacks(temp_nr, all_occupancy);
                temp_something = get_bishop_attacks(temp_nr, all_occupancy) & ~all_occupancy;
                temp_control_square_worth = 10;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something & get_king_attacks(temp_nr)) * 3;
                eval += get_xray_attacks(BOARD, get_bishop_attacks(temp_nr, empty_board), true, 'b', temp_nr);
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.white.rooks)) != 0) {
        eval += temp_n * rook_value * rookValue;
        temp_pieces = BOARD.white.rooks;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval -= rook_value * 0.15;
            }
            else if (ERoMoE > -1) {
                control |= get_rook_attacks(temp_nr, all_occupancy);
                temp_something = get_rook_attacks(temp_nr, all_occupancy) & ~all_occupancy;
                temp_control_square_worth = 10;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something & get_king_attacks(temp_nr)) * 3;
                eval += get_xray_attacks(BOARD, get_rook_attacks(temp_nr, empty_board), true, 'r', temp_nr);
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.white.queen)) != 0) {
        eval += temp_n * queen_value * queenValue;
        temp_pieces = BOARD.white.queen;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
                eval -= queen_value * 0.1;
            }
            else if (ERoMoE > -1) {
                control |= get_queen_attacks(temp_nr, all_occupancy);
                temp_something = get_queen_attacks(temp_nr, all_occupancy) & ~all_occupancy;
                temp_control_square_worth = 15;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something & get_king_attacks(temp_nr)) * 3;
                eval += get_xray_attacks(BOARD, get_queen_attacks(temp_nr, empty_board), true, 'q', temp_nr);
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }


    eval += king_value;
    temp_pieces = BOARD.white.king;
    temp_nr = find_first_set_bit(temp_pieces);

    if (ERoMoE < 1) {
        eval += EarlyGameHideKingInTheCorner[temp_nr];
    }
    else if (ERoMoE == 0) {
        control |= get_king_attacks(temp_nr);
        eval += Count_bits(get_king_attacks(temp_nr) & ~all_occupancy) * 10;
    }
    else {
        control |= get_king_attacks(temp_nr);
        eval += ENDGAMEkingcentercontrol[temp_nr];
    }

    //eval pawn structure
    if (ERoMoE > -1) {
        int engame_multiplier = 1;
        if (ERoMoE == 1)engame_multiplier = 2;
        if ((temp_pieces = passed_pawns) != 0) {
            while (temp_pieces != 0) {
                temp_nr = find_first_set_bit(temp_pieces);
                eval += 25 * engame_multiplier * bonus_for_further_passers[temp_nr];//63- for black
                if (get_bit(control, temp_nr) != 0)eval += 25 * engame_multiplier * bonus_for_further_passers[temp_nr];
                else if ((passed_pawns & get_king_attacks(temp_nr)) != 0) {
                    eval += 25 * engame_multiplier * bonus_for_further_passers[temp_nr];//63- for black
                    if (Count_bits(passed_pawns & get_king_attacks(temp_nr)) > 1) add_more_detailed_eval += 1.25;//more eval for 3 or more passers
                }
                pop_bit(temp_pieces, temp_nr);
            }
            //calculating the distance between passed pawns
            if (count_bits(passed_pawns) > 1) {
                int count = 0, slider = 1, bonus = 0;
                bool ehehehehe = false;
                if ((trim_left & passed_pawns) != 0) {
                    ehehehehe = true;
                }
                while (slider < 8) {
                    if (((trim_left >> slider) & passed_pawns) != 0) {
                        if (ehehehehe)bonus += count * 5;
                        ehehehehe = true;
                        count = 0;
                    }
                    else if (ehehehehe) {
                        count++;
                    }
                    slider++;
                }
                eval += bonus;
            }
        }
        if (doubled_pawns != 0) {
            eval += Count_bits(doubled_pawns) * -20 * engame_multiplier;
        }
        if (isolated_pawns != 0) {
            eval += Count_bits(isolated_pawns) * -20 * engame_multiplier;
        }
        if (backwards_pawns != 0) {
            while (backwards_pawns != 0) {
                temp_nr = find_first_set_bit(backwards_pawns);
                if (temp_nr / 8 < 5)//black > 2
                    eval += -25 * pow(0.5, (temp_nr / 8 - 1)) * engame_multiplier;//black 63-
                pop_bit(backwards_pawns, temp_nr);
            }
        }
        if (semi_backwards_pawns != 0) {
            while (semi_backwards_pawns != 0) {
                temp_nr = find_first_set_bit(semi_backwards_pawns);//black 63-
                if (temp_nr / 8 < 3)
                    eval += -15 * pow(0.5, (temp_nr / 8 - 1)) * engame_multiplier;
                pop_bit(semi_backwards_pawns, temp_nr);
            }
        }
        if (backwards_fated_pawns != 0) {
            while (backwards_fated_pawns != 0) {
                temp_nr = find_first_set_bit(backwards_fated_pawns);//black 63-
                if (temp_nr / 8 < 5)
                    eval += -35 * pow(0.5, (temp_nr / 8 - 1)) * engame_multiplier;
                pop_bit(backwards_fated_pawns, temp_nr);
            }
        }
    }
    //control and defense
    if (ERoMoE > -1) {
        eval += get_attacked_pieces_value(BOARD, (control & black_occupancy), true);
        eval += 0.5 * get_attacked_pieces_value(BOARD, (control & white_occupancy), true);
        if ((temp_n = Count_bits(~control & white_occupancy)) != 0) {
            if (temp_n < 3)eval += temp_n * -5;
            else eval += temp_n * -7;
        }
        add_more_detailed_eval += Count_bits(~control & BOARD.white.pawns) * -0.4;//undefended pawns
    }

    eval += add_more_detailed_eval;

    add_more_detailed_eval = 0;
    control = 0;
    passed_pawns = 0;
    doubled_pawns = 0;
    isolated_pawns = 0;
    backwards_pawns = 0;
    semi_backwards_pawns = 0;
    backwards_fated_pawns = 0;


    finalEval += eval;
    eval = 0;

    temp_pieces = black_occupancy;

    if (ERoMoE == -1) {
        double temp_eval_for_oppening0 = 0, temp_eval_for_oppening1 = 0, temp_eval_for_oppening2 = 0;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            temp_eval_for_oppening1 += general_go_forwardW[63 - temp_nr];
            if (get_bit(level_1_square, temp_nr) != 0)temp_eval_for_oppening2 += 2.5;
            else if (get_bit(level_2_square, temp_nr) != 0)temp_eval_for_oppening2 += 5;
            else if (get_bit(level_3_square, temp_nr) != 0)temp_eval_for_oppening2 += 7.5;
            else if (get_bit(level_4_square, temp_nr) != 0)temp_eval_for_oppening2 += 10;
            pop_bit(temp_pieces, temp_nr);
        }
        add_more_detailed_eval += temp_eval_for_oppening1 + temp_eval_for_oppening1 + (temp_eval_for_oppening1 + temp_eval_for_oppening2) / 2;
    }



    if ((temp_n = Count_bits(BOARD.black.pawns)) != 0) {
        temp_pieces = BOARD.black.pawns;
        eval += temp_n * pawn_value;
        if (ERoMoE > -1) {
            eval += (Count_bits(get_all_pawn_attacks(BOARD.black.pawns, false)) + Count_bits(get_all_pawn_moves(BOARD.black.pawns, all_occupancy, false))) * 5;
            control |= get_all_pawn_attacks(BOARD.black.pawns, false);
        }
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
                eval += EarlyGameCenterControlForPawnsB[temp_nr];
            }
            else if (ERoMoE > -1) {

                if ((BOARD.black.pawns & (trim_left >> temp_nr % 8)) == 0) { set_bit(passed_pawns, temp_nr); }

                pop_bit(BOARD.black.pawns, temp_nr);
                if ((BOARD.black.pawns & (trim_left >> temp_nr % 8)) != 0) { set_bit(doubled_pawns, temp_nr); }
                set_bit(BOARD.black.pawns, temp_nr);

                if ((BOARD.black.pawns & get_king_attacks(temp_nr)) == 0) { set_bit(isolated_pawns, temp_nr); }

                if (get_bit(get_all_pawn_attacks(BOARD.white.pawns, true), temp_nr - 8) != 0) {
                    if (get_bit(get_all_pawn_attacks(BOARD.black.pawns, false), temp_nr - 8) != 0)
                        set_bit(semi_backwards_pawns, temp_nr);
                    else {
                        if (Count_bits(BOARD.black.pawns & get_pawn_attacks(temp_nr - 8, false)) == 2)
                            set_bit(backwards_fated_pawns, temp_nr);
                        else {
                            set_bit(backwards_pawns, temp_nr);
                        }
                    }
                }
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.black.knights)) != 0) {
        eval += temp_n * knight_value * knightValue;
        temp_pieces = BOARD.black.knights;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
                eval += EarlyGamemoveTheKnightInTheCenter[temp_nr];
            }
            else if (ERoMoE > -1) {
                control |= get_knight_attacks(temp_nr);
                temp_something = get_knight_attacks(temp_nr) & ~all_occupancy;
                temp_control_square_worth = 15;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something) / 2 * 3;
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.black.bishops)) != 0) {
        eval += temp_n * bishop_value * bishopValue;
        temp_pieces = BOARD.black.bishops;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
            }
            else if (ERoMoE > -1) {
                control |= get_bishop_attacks(temp_nr, all_occupancy);
                temp_something = get_bishop_attacks(temp_nr, all_occupancy) & ~all_occupancy;
                temp_control_square_worth = 10;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something & get_king_attacks(temp_nr)) * 3;
                eval += get_xray_attacks(BOARD, get_bishop_attacks(temp_nr, empty_board), false, 'b', temp_nr);
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.black.rooks)) != 0) {
        eval += temp_n * rook_value * rookValue;
        temp_pieces = BOARD.black.rooks;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval -= rook_value * 0.15;
            }
            else if (ERoMoE > -1) {
                control |= get_rook_attacks(temp_nr, all_occupancy);
                temp_something = get_rook_attacks(temp_nr, all_occupancy) & ~all_occupancy;
                temp_control_square_worth = 10;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something & get_king_attacks(temp_nr)) * 3;
                eval += get_xray_attacks(BOARD, get_rook_attacks(temp_nr, empty_board), false, 'r', temp_nr);
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }
    if ((temp_n = Count_bits(BOARD.black.queen)) != 0) {
        eval += temp_n * queen_value * queenValue;
        temp_pieces = BOARD.black.queen;
        while (temp_pieces != 0) {
            temp_nr = find_first_set_bit(temp_pieces);
            if (ERoMoE == -1) {
                eval += EarlyGameWiderCenterControl[temp_nr];
                eval -= queen_value * 0.1;
            }
            else if (ERoMoE > -1) {
                control |= get_queen_attacks(temp_nr, all_occupancy);
                temp_something = get_queen_attacks(temp_nr, all_occupancy) & ~all_occupancy;
                temp_control_square_worth = 15;
                eval +=
                    Count_bits(temp_something & level_1_square) * temp_control_square_worth
                    + Count_bits(temp_something & level_2_square) * 1.25 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.56 * temp_control_square_worth
                    + Count_bits(temp_something & level_3_square) * 1.95 * temp_control_square_worth;
                eval += Count_bits(temp_something & get_king_attacks(temp_nr)) * 3;
                eval += get_xray_attacks(BOARD, get_queen_attacks(temp_nr, empty_board), false, 'q', temp_nr);
            }
            pop_bit(temp_pieces, temp_nr);
        }
    }


    eval += king_value;
    temp_pieces = BOARD.black.king;
    temp_nr = find_first_set_bit(temp_pieces);

    if (ERoMoE < 1) {
        eval += EarlyGameHideKingInTheCorner[temp_nr];
    }
    else if (ERoMoE == 0) {
        eval += Count_bits(get_king_attacks(temp_nr) & ~all_occupancy) * 10;
        control |= get_king_attacks(temp_nr);
    }
    else {
        eval += ENDGAMEkingcentercontrol[temp_nr];
        control |= get_king_attacks(temp_nr);
    }


    //eval pawn structure
    if (ERoMoE > -1) {
        int engame_multiplier = 1;
        if (ERoMoE == 1)engame_multiplier = 2;
        if ((temp_pieces = passed_pawns) != 0) {
            while (temp_pieces != 0) {
                temp_nr = find_first_set_bit(temp_pieces);
                eval += 25 * engame_multiplier * bonus_for_further_passers[63 - temp_nr];//63- for black
                if (get_bit(control, temp_nr) != 0)eval += 25 * engame_multiplier * bonus_for_further_passers[63 - temp_nr];
                else if ((passed_pawns & get_king_attacks(temp_nr)) != 0) {
                    eval += 25 * engame_multiplier * bonus_for_further_passers[63 - temp_nr];//63- for black
                    if (Count_bits(passed_pawns & get_king_attacks(temp_nr)) > 1) add_more_detailed_eval += 1.25;//more eval for 3 or more passers
                }
                pop_bit(temp_pieces, temp_nr);
            }
            //calculating the distance between passed pawns
            if (count_bits(passed_pawns) > 1) {
                int count = 0, slider = 1, bonus = 0;
                bool ehehehehe = false;
                if ((trim_left & passed_pawns) != 0) {
                    ehehehehe = true;
                }
                while (slider < 8) {
                    if (((trim_left >> slider) & passed_pawns) != 0) {
                        if (ehehehehe)bonus += count * 5;
                        ehehehehe = true;
                        count = 0;
                    }
                    else if (ehehehehe) {
                        count++;
                    }
                    slider++;
                }
                eval += bonus;
            }
        }
        if (doubled_pawns != 0) {
            eval += Count_bits(doubled_pawns) * -20 * engame_multiplier;
        }
        if (isolated_pawns != 0) {
            eval += Count_bits(isolated_pawns) * -20 * engame_multiplier;
        }
        if (backwards_pawns != 0) {
            while (backwards_pawns != 0) {
                temp_nr = find_first_set_bit(backwards_pawns);
                if (temp_nr / 8 > 2)//black > 2
                    eval += -25 * pow(0.5, (63 - (temp_nr / 8 - 1))) * engame_multiplier;//black 63-
                pop_bit(backwards_pawns, temp_nr);
            }
        }
        if (semi_backwards_pawns != 0) {
            while (semi_backwards_pawns != 0) {
                temp_nr = find_first_set_bit(semi_backwards_pawns);//black 63-
                if (temp_nr / 8 < 3)
                    eval += -15 * pow(0.5, (63 - (temp_nr / 8 - 1))) * engame_multiplier;
                pop_bit(semi_backwards_pawns, temp_nr);
            }
        }
        if (backwards_fated_pawns != 0) {
            while (backwards_fated_pawns != 0) {
                temp_nr = find_first_set_bit(backwards_fated_pawns);//black 63-
                if (temp_nr / 8 < 5)
                    eval += -35 * pow(0.5, (63 - (temp_nr / 8 - 1))) * engame_multiplier;
                pop_bit(backwards_fated_pawns, temp_nr);
            }
        }
    }
    //control and defense
    if (ERoMoE > -1) {
        eval += get_attacked_pieces_value(BOARD, (control & white_occupancy), false);
        eval += 0.5 * get_attacked_pieces_value(BOARD, (control & black_occupancy), false);
        if ((temp_n = Count_bits(~control & black_occupancy)) != 0) {
            if (temp_n < 3)eval += temp_n * -5;
            else eval += temp_n * -7;
        }
        add_more_detailed_eval += Count_bits(~control & BOARD.black.pawns) * -0.4;
    }



    eval += add_more_detailed_eval;



    finalEval -= eval;

    return finalEval;
}
void check_for_king_check_and_continue_if_no(chessboard BOARD, int depth, bool White, int& alpha, int& beta, int& eval, bool& are_there_any_legal_moves, bool& skip_available, bool stable_position);
bool king_in_check(chessboard BOARD, bool white) {
    int kingsquare;
    uint64_t temp_attack, all_occupancy = get_occupancy(BOARD);
    if (white) {
        kingsquare = (BOARD.king_squares / 100);
        if ((((temp_attack = get_bishop_attacks(kingsquare, all_occupancy)) & BOARD.black.bishops) != 0) || ((temp_attack & BOARD.black.queen) != 0))return true;
        if ((((temp_attack = get_rook_attacks(kingsquare, all_occupancy)) & BOARD.black.rooks) != 0) || ((temp_attack & BOARD.black.queen) != 0))return true;
        if ((get_knight_attacks(kingsquare) & BOARD.black.knights) != 0)return true;
        if ((get_king_attacks(kingsquare) & BOARD.black.king) != 0)return true;
        if (((((BOARD.white.king & ~trim_left) << (BOARD_WIDTH + 1)) & BOARD.black.pawns) != 0) || ((((BOARD.white.king & ~trim_right) << (BOARD_WIDTH - 1)) & BOARD.black.pawns) != 0)) return true;
    }
    else {
        kingsquare = (BOARD.king_squares % 100);
        if ((((temp_attack = get_bishop_attacks(kingsquare, all_occupancy)) & BOARD.white.bishops) != 0) || ((temp_attack & BOARD.white.queen) != 0))return true;
        if ((((temp_attack = get_rook_attacks(kingsquare, all_occupancy)) & BOARD.white.rooks) != 0) || ((temp_attack & BOARD.white.queen) != 0))return true;
        if ((get_knight_attacks(kingsquare) & BOARD.white.knights) != 0)return true;
        if ((get_king_attacks(kingsquare) & BOARD.white.king) != 0)return true;
        if (((((BOARD.black.king & ~trim_left) >> (BOARD_WIDTH - 1)) & BOARD.white.pawns) != 0) || ((((BOARD.black.king & ~trim_right) >> (BOARD_WIDTH + 1)) & BOARD.white.pawns) != 0)) return true;
    }
    return false;
}
bool is_position_stable(chessboard BOARD, bool white_to_go) {
    uint64_t colour_occupancy, counter = 0, opponent_occupancy, all_occupancy, temp_colour_occupancy;
    int square;
    all_occupancy = get_occupancy(BOARD);
    if (white_to_go) {
        colour_occupancy = get_occupancy(BOARD.white);
        opponent_occupancy = get_occupancy(BOARD.black);
        temp_colour_occupancy = colour_occupancy;
        if (((get_all_pawn_attacks(BOARD.white.pawns, white_to_go) & opponent_occupancy) != 0) || ((get_all_pawn_attacks(BOARD.white.pawns, white_to_go) & (get_pawn_moves(all_occupancy, BOARD.king_squares % 100, !white_to_go, opponent_occupancy) & get_all_pawn_attacks(BOARD.black.pawns, !white_to_go))) != 0))
            return false;
        temp_colour_occupancy ^= BOARD.white.pawns;
        while (temp_colour_occupancy != 0) {
            square = find_first_set_bit(temp_colour_occupancy);
            set_bit(counter, square);//I think this below check for attacks and checks (im not sure tbh) 
            if (((BOARD.white.knights & counter) != 0) && (((get_knight_attacks(square) & opponent_occupancy) != 0) || ((get_knight_attacks(square) & get_knight_attacks(BOARD.king_squares % 100)) != 0)))return false;
            if (((BOARD.white.bishops & counter) != 0) && (((get_bishop_attacks(square, all_occupancy) & opponent_occupancy) != 0) || ((get_bishop_attacks(square, opponent_occupancy) & get_bishop_attacks(BOARD.king_squares % 100, opponent_occupancy)) != 0)))return false;
            if (((BOARD.white.king & counter) != 0) && (((get_king_attacks(square) & opponent_occupancy) != 0) || (((get_king_attacks(square) & get_king_attacks(BOARD.king_squares % 100)) != 0))))return false;
            if (((BOARD.white.queen & counter) != 0) && (((get_queen_attacks(square, all_occupancy) & opponent_occupancy) != 0) || ((get_queen_attacks(square, opponent_occupancy) & get_queen_attacks(BOARD.king_squares % 100, opponent_occupancy)) != 0)))return false;
            if (((BOARD.white.rooks & counter) != 0) && (((get_rook_attacks(square, all_occupancy) & opponent_occupancy) != 0) || ((get_rook_attacks(square, opponent_occupancy) & get_rook_attacks(BOARD.king_squares % 100, opponent_occupancy)) != 0)))return false;
            pop_bit(temp_colour_occupancy, square);
            counter = 0;
        }
    }
    else {
        colour_occupancy = get_occupancy(BOARD.black);
        opponent_occupancy = get_occupancy(BOARD.white);
        temp_colour_occupancy = colour_occupancy;
        if (((get_all_pawn_attacks(BOARD.black.pawns, white_to_go) & opponent_occupancy) != 0) || ((get_all_pawn_attacks(BOARD.black.pawns, white_to_go) & (get_pawn_moves(all_occupancy, BOARD.king_squares / 100, !white_to_go, opponent_occupancy) & get_all_pawn_attacks(BOARD.white.pawns, !white_to_go))) != 0))
            return false;
        temp_colour_occupancy ^= BOARD.black.pawns;
        while (temp_colour_occupancy != 0) {
            square = find_first_set_bit(temp_colour_occupancy);
            set_bit(counter, square);
            if (((BOARD.black.knights & counter) != 0) && (((get_knight_attacks(square) & opponent_occupancy) != 0) || ((get_knight_attacks(square) & get_knight_attacks(BOARD.king_squares / 100)) != 0)))return false;
            if (((BOARD.black.bishops & counter) != 0) && (((get_bishop_attacks(square, all_occupancy) & opponent_occupancy) != 0) || ((get_bishop_attacks(square, opponent_occupancy) & get_bishop_attacks(BOARD.king_squares / 100, opponent_occupancy)) != 0)))return false;
            if (((BOARD.black.king & counter) != 0) && (((get_king_attacks(square) & opponent_occupancy) != 0) || (((get_king_attacks(square) & get_king_attacks(BOARD.king_squares / 100)) != 0))))return false;
            if (((BOARD.black.queen & counter) != 0) && (((get_queen_attacks(square, all_occupancy) & opponent_occupancy) != 0) || ((get_queen_attacks(square, opponent_occupancy) & get_queen_attacks(BOARD.king_squares / 100, opponent_occupancy)) != 0)))return false;
            if (((BOARD.black.rooks & counter) != 0) && (((get_rook_attacks(square, all_occupancy) & opponent_occupancy) != 0) || ((get_rook_attacks(square, opponent_occupancy) & get_rook_attacks(BOARD.king_squares / 100, opponent_occupancy)) != 0)))return false;
            pop_bit(temp_colour_occupancy, square);
            counter = 0;
        }
    }
    return true;
}
void generate_movess(chessboard BOARD, int depth, int White, int alpha, int beta, int& eval, bool stable_position) {
    bool are_there_any_legal_moves = false, skip_available = false;
    if (depth > 0) {
        stable_position = true;
        int temp_eval = 100000;
        if (White)
            temp_eval = -100000;
        uint64_t white_occupancy = get_occupancy(BOARD.white), counter = 0, all_occupancy = get_occupancy(BOARD), black_occupancy = all_occupancy ^ white_occupancy, temp_move, temp_capture, temp_white_occupancy = white_occupancy, temp_black_occupancy = black_occupancy;
        int square = 0, move_to_square, restore_to, temp_castling = 0;
        if (BOARD.keep_en_passant)BOARD.keep_en_passant = 0;
        else BOARD.en_passant = 0;
        if (White) {
            while (temp_white_occupancy != 0) {
                square = find_first_set_bit(temp_white_occupancy);
                set_bit(counter, square);
                if (((BOARD.white.pawns & counter) != 0) && ((temp_move = get_pawn_moves(all_occupancy, square, White, black_occupancy)) != 0)) {
                    pop_bit(BOARD.white.pawns, square);
                    if (square > a6) {
                        temp_capture = temp_move & black_occupancy;
                        temp_move ^= temp_capture;
                        while (temp_capture != 0) {
                            set_bit(BOARD.white.queen, (move_to_square = find_first_set_bit(temp_capture)));
                            delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                            stable_position = 0;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            stable_position = 1;
                            restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                            pop_bit(BOARD.white.queen, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip1;
                        }
                        if (temp_move != 0) {
                            set_bit(BOARD.white.queen, (move_to_square = square + BOARD_WIDTH));
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            pop_bit(BOARD.white.queen, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip1;
                        }
                    }
                    else if (square < h3) {
                        temp_capture = temp_move & black_occupancy;
                        temp_move ^= temp_capture;
                        while (temp_capture != 0) {
                            set_bit(BOARD.white.pawns, (move_to_square = find_first_set_bit(temp_capture)));
                            delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                            stable_position = 0;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            stable_position = 1;
                            restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                            pop_bit(BOARD.white.pawns, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip1;
                        }
                        if (temp_move != 0) {
                            pop_bit(temp_move, (move_to_square = square + BOARD_WIDTH));
                            if (temp_move != 0) {
                                BOARD.en_passant = square + BOARD_WIDTH;
                                BOARD.keep_en_passant = 1;

                                set_bit(BOARD.white.pawns, (move_to_square = square + BOARD_WIDTH * 2));
                                check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                                pop_bit(BOARD.white.pawns, move_to_square);
                                pop_bit(temp_move, move_to_square);

                                BOARD.keep_en_passant = 0;
                                BOARD.en_passant = 0;
                                if (skip_available)
                                    goto restore_move_and_skip1;
                            }

                            set_bit(BOARD.white.pawns, (move_to_square = square + BOARD_WIDTH));
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            pop_bit(BOARD.white.pawns, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip1;
                        }
                    }
                    else {
                        if (BOARD.en_passant != 0) {
                            uint64_t enpassantsquare = 0;
                            set_bit(enpassantsquare, BOARD.en_passant);
                            temp_capture = temp_move & (black_occupancy | enpassantsquare);
                        }
                        else
                            temp_capture = temp_move & black_occupancy;
                        temp_move ^= temp_capture;
                        while (temp_capture != 0) {
                            set_bit(BOARD.white.pawns, (move_to_square = find_first_set_bit(temp_capture)));
                            delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                            stable_position = 0;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            stable_position = 1;
                            restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                            pop_bit(BOARD.white.pawns, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip1;
                        }
                        if (temp_move != 0) {
                            set_bit(BOARD.white.pawns, (move_to_square = square + BOARD_WIDTH));
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            pop_bit(BOARD.white.pawns, move_to_square);
                            pop_bit(temp_move, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip1;
                        }
                    }
                restore_move_and_skip1:
                    set_bit(BOARD.white.pawns, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.white.knights & counter) != 0) && ((temp_move = (get_knight_attacks(square) & ~white_occupancy)) != 0)) {
                    pop_bit(BOARD.white.knights, square);
                    temp_capture = temp_move & black_occupancy;
                    temp_move ^= temp_capture;
                    while (temp_capture != 0) {
                        set_bit(BOARD.white.knights, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.white.knights, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip2;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.white.knights, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.white.knights, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip2;
                    }
                restore_move_and_skip2:
                    set_bit(BOARD.white.knights, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.white.bishops & counter) != 0) && ((temp_move = (get_bishop_attacks(square, all_occupancy) & ~white_occupancy)) != 0)) {
                    pop_bit(BOARD.white.bishops, square);
                    temp_capture = temp_move & black_occupancy;
                    temp_move ^= temp_capture;
                    while (temp_capture != 0) {
                        set_bit(BOARD.white.bishops, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.white.bishops, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip3;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.white.bishops, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.white.bishops, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip3;
                    }
                restore_move_and_skip3:
                    set_bit(BOARD.white.bishops, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.white.king & counter) != 0) && ((temp_move = (get_king_attacks(square) & ~white_occupancy)) != 0)) {
                    pop_bit(BOARD.white.king, square);
                    temp_capture = temp_move & black_occupancy;
                    temp_move ^= temp_capture;
                    if ((BOARD.castling & 12) != 0) {
                        if ((BOARD.castling & 8) != 0 && (counter << 1 & all_occupancy) == 0 && (counter << 2 & all_occupancy) == 0 && (counter << 3 & all_occupancy) == 0) {
                            pop_bit(BOARD.white.rooks, a1);
                            set_bit(BOARD.white.rooks, d1);
                            set_bit(BOARD.white.king, c1);
                            temp_castling = BOARD.castling;
                            BOARD.castling &= 3;
                            BOARD.king_squares = BOARD.king_squares % 100 + c1 * 100;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            BOARD.king_squares = square * 100 + BOARD.king_squares % 100;
                            BOARD.castling = temp_castling;
                            set_bit(BOARD.white.rooks, a1);
                            pop_bit(BOARD.white.rooks, d1);
                            pop_bit(BOARD.white.king, c1);
                        }
                        if ((BOARD.castling & 4) != 0 && (counter >> 1 & all_occupancy) == 0 && (counter >> 2 & all_occupancy) == 0) {
                            pop_bit(BOARD.white.rooks, h1);
                            set_bit(BOARD.white.rooks, f1);
                            set_bit(BOARD.white.king, g1);
                            temp_castling = BOARD.castling;
                            BOARD.castling &= 3;
                            BOARD.king_squares = BOARD.king_squares % 100 + g1 * 100;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            BOARD.king_squares = square * 100 + BOARD.king_squares % 100;
                            BOARD.castling = temp_castling;
                            set_bit(BOARD.white.rooks, h1);
                            pop_bit(BOARD.white.rooks, f1);
                            pop_bit(BOARD.white.king, g1);
                        }
                    }
                    temp_castling = BOARD.castling;
                    BOARD.castling = BOARD.castling & 3;
                    while (temp_capture != 0) {
                        set_bit(BOARD.white.king, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        BOARD.king_squares = move_to_square * 100 + BOARD.king_squares % 100;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        BOARD.king_squares = square * 100 + BOARD.king_squares % 100;
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.white.king, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip4;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.white.king, (move_to_square = find_first_set_bit(temp_move)));
                        BOARD.king_squares = move_to_square * 100 + BOARD.king_squares % 100;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        BOARD.king_squares = square * 100 + BOARD.king_squares % 100;
                        pop_bit(BOARD.white.king, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip4;
                    }
                restore_move_and_skip4:
                    BOARD.castling = temp_castling;
                    temp_castling = 0;
                    set_bit(BOARD.white.king, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.white.queen & counter) != 0) && ((temp_move = (get_queen_attacks(square, all_occupancy) & ~white_occupancy)) != 0)) {
                    pop_bit(BOARD.white.queen, square);
                    temp_capture = temp_move & black_occupancy;
                    temp_move ^= temp_capture;
                    while (temp_capture != 0) {
                        set_bit(BOARD.white.queen, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.white.queen, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip5;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.white.queen, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.white.queen, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip5;
                    }
                restore_move_and_skip5:
                    set_bit(BOARD.white.queen, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.white.rooks & counter) != 0) && ((temp_move = (get_rook_attacks(square, all_occupancy) & ~white_occupancy)) != 0)) {
                    pop_bit(BOARD.white.rooks, square);
                    temp_capture = temp_move & black_occupancy;
                    temp_move ^= temp_capture;
                    if ((BOARD.castling & 12) != 0) {
                        temp_castling = BOARD.castling;
                        if ((BOARD.castling & 8) != 0) {
                            BOARD.castling = BOARD.castling ^ 8;
                        }
                        if ((BOARD.castling & 4) != 0) {
                            BOARD.castling = BOARD.castling ^ 4;
                        }
                    }
                    while (temp_capture != 0) {
                        set_bit(BOARD.white.rooks, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.white.rooks, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip6;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.white.rooks, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.white.rooks, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip6;
                    }
                restore_move_and_skip6:
                    BOARD.castling = temp_castling;
                    set_bit(BOARD.white.rooks, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                pop_bit(temp_white_occupancy, square);
                counter = 0;
            }
        }
        else {
            while (temp_black_occupancy != 0) {
                square = find_first_set_bit(temp_black_occupancy);
                set_bit(counter, square);
                if (((BOARD.black.pawns & counter) != 0) && ((temp_move = get_pawn_moves(all_occupancy, square, White, white_occupancy)) != 0)) {
                    pop_bit(BOARD.black.pawns, square);
                    if (square < h3) {
                        temp_capture = temp_move & white_occupancy;
                        temp_move ^= temp_capture;
                        while (temp_capture != 0) {
                            set_bit(BOARD.black.queen, (move_to_square = find_first_set_bit(temp_capture)));
                            delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                            stable_position = 0;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            stable_position = 1;
                            restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                            pop_bit(BOARD.black.queen, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip7;
                        }
                        if (temp_move != 0) {
                            set_bit(BOARD.black.queen, (move_to_square = square - BOARD_WIDTH));
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            pop_bit(BOARD.black.queen, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip7;
                        }
                    }
                    else if (square > a6) {
                        temp_capture = temp_move & white_occupancy;
                        temp_move ^= temp_capture;
                        while (temp_capture != 0) {
                            set_bit(BOARD.black.pawns, (move_to_square = find_first_set_bit(temp_capture)));
                            delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                            stable_position = 0;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            stable_position = 1;
                            restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                            pop_bit(BOARD.black.pawns, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip7;
                        }
                        if (temp_move != 0) {
                            pop_bit(temp_move, (move_to_square = square - BOARD_WIDTH));
                            if (temp_move != 0) {
                                BOARD.en_passant = square + BOARD_WIDTH;
                                BOARD.keep_en_passant = 1;

                                set_bit(BOARD.black.pawns, (move_to_square = square - BOARD_WIDTH * 2));
                                check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                                pop_bit(BOARD.black.pawns, move_to_square);
                                pop_bit(temp_move, move_to_square);

                                BOARD.keep_en_passant = 0;
                                BOARD.en_passant = 0;
                                if (skip_available)
                                    goto restore_move_and_skip7;
                            }
                            set_bit(BOARD.black.pawns, (move_to_square = square - BOARD_WIDTH));
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            pop_bit(BOARD.black.pawns, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip7;
                        }
                    }
                    else {
                        if (BOARD.en_passant != 0) {
                            uint64_t enpassantsquare = 0;
                            set_bit(enpassantsquare, BOARD.en_passant);
                            temp_capture = temp_move & (white_occupancy | enpassantsquare);
                        }
                        else
                            temp_capture = temp_move & white_occupancy;
                        temp_move ^= temp_capture;
                        while (temp_capture != 0) {
                            set_bit(BOARD.black.pawns, (move_to_square = find_first_set_bit(temp_capture)));
                            delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                            stable_position = 0;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            stable_position = 1;
                            restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                            pop_bit(BOARD.black.pawns, move_to_square);
                            pop_bit(temp_capture, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip7;
                        }
                        if (temp_move != 0) {
                            set_bit(BOARD.black.pawns, (move_to_square = square - BOARD_WIDTH));
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            pop_bit(BOARD.black.pawns, move_to_square);
                            pop_bit(temp_move, move_to_square);
                            if (skip_available)
                                goto restore_move_and_skip7;
                        }
                    }
                restore_move_and_skip7:
                    set_bit(BOARD.black.pawns, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.black.knights & counter) != 0) && ((temp_move = (get_knight_attacks(square) & ~black_occupancy)) != 0)) {
                    pop_bit(BOARD.black.knights, square);
                    temp_capture = temp_move & white_occupancy;
                    temp_move ^= temp_capture;
                    while (temp_capture != 0) {
                        set_bit(BOARD.black.knights, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.black.knights, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip8;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.black.knights, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.black.knights, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip8;
                    }
                restore_move_and_skip8:
                    set_bit(BOARD.black.knights, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.black.bishops & counter) != 0) && ((temp_move = (get_bishop_attacks(square, all_occupancy) & ~black_occupancy)) != 0)) {
                    pop_bit(BOARD.black.bishops, square);
                    temp_capture = temp_move & white_occupancy;
                    temp_move ^= temp_capture;
                    while (temp_capture != 0) {
                        set_bit(BOARD.black.bishops, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.black.bishops, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip9;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.black.bishops, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.black.bishops, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip9;
                    }
                restore_move_and_skip9:
                    set_bit(BOARD.black.bishops, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.black.king & counter) != 0) && ((temp_move = (get_king_attacks(square) & ~black_occupancy)) != 0)) {
                    pop_bit(BOARD.black.king, square);
                    temp_capture = temp_move & white_occupancy;
                    temp_move ^= temp_capture;
                    if ((BOARD.castling & 3) != 0) {
                        if ((BOARD.castling & 2) != 0 && (counter << 1 & all_occupancy) == 0 && (counter << 2 & all_occupancy) == 0 && (counter << 3 & all_occupancy) == 0) {
                            pop_bit(BOARD.black.rooks, a8);
                            set_bit(BOARD.black.rooks, d8);
                            set_bit(BOARD.black.king, c8);
                            temp_castling = BOARD.castling;
                            BOARD.castling &= 12;
                            BOARD.king_squares = (BOARD.king_squares / 100) * 100 + c8;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            BOARD.king_squares = square + (BOARD.king_squares / 100) * 100;
                            BOARD.castling = temp_castling;
                            set_bit(BOARD.black.rooks, a8);
                            pop_bit(BOARD.black.rooks, d8);
                            pop_bit(BOARD.black.king, c8);
                        }
                        if ((BOARD.castling & 1) != 0 && (counter >> 1 & all_occupancy) == 0 && (counter >> 2 & all_occupancy) == 0) {
                            pop_bit(BOARD.black.rooks, h8);
                            set_bit(BOARD.black.rooks, f8);
                            set_bit(BOARD.black.king, g8);
                            temp_castling = BOARD.castling;
                            BOARD.castling &= 12;
                            BOARD.king_squares = (BOARD.king_squares / 100) * 100 + g8;
                            check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                            BOARD.king_squares = square + (BOARD.king_squares / 100) * 100;
                            BOARD.castling = temp_castling;
                            set_bit(BOARD.black.rooks, h8);
                            pop_bit(BOARD.black.rooks, f8);
                            pop_bit(BOARD.black.king, g8);
                        }
                    }
                    temp_castling = BOARD.castling;
                    BOARD.castling = BOARD.castling & 12;
                    while (temp_capture != 0) {
                        set_bit(BOARD.black.king, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        BOARD.king_squares = move_to_square + (BOARD.king_squares / 100) * 100;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        BOARD.king_squares = square + (BOARD.king_squares / 100) * 100;
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.black.king, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip10;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.black.king, (move_to_square = find_first_set_bit(temp_move)));
                        BOARD.king_squares = move_to_square + (BOARD.king_squares / 100) * 100;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        BOARD.king_squares = square + (BOARD.king_squares / 100) * 100;
                        pop_bit(BOARD.black.king, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip10;
                    }
                restore_move_and_skip10:
                    BOARD.castling = temp_castling;
                    temp_castling = 0;
                    set_bit(BOARD.black.king, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.black.queen & counter) != 0) && ((temp_move = (get_queen_attacks(square, all_occupancy) & ~black_occupancy)) != 0)) {
                    pop_bit(BOARD.black.queen, square);
                    temp_capture = temp_move & white_occupancy;
                    temp_move ^= temp_capture;
                    while (temp_capture != 0) {
                        set_bit(BOARD.black.queen, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.black.queen, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip11;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.black.queen, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.black.queen, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip11;
                    }
                restore_move_and_skip11:
                    set_bit(BOARD.black.queen, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                else if (((BOARD.black.rooks & counter) != 0) && ((temp_move = (get_rook_attacks(square, all_occupancy) & ~black_occupancy)) != 0)) {
                    pop_bit(BOARD.black.rooks, square);
                    temp_capture = temp_move & white_occupancy;
                    temp_move ^= temp_capture;
                    if ((BOARD.castling & 3) != 0) {
                        temp_castling = BOARD.castling;
                        if ((BOARD.castling & 2) != 0) {
                            BOARD.castling = BOARD.castling ^ 2;
                        }
                        if ((BOARD.castling & 1) != 0) {
                            BOARD.castling = BOARD.castling ^ 1;
                        }
                    }
                    while (temp_capture != 0) {
                        set_bit(BOARD.black.rooks, (move_to_square = find_first_set_bit(temp_capture)));
                        delete_opponents_piece(BOARD, move_to_square, White, restore_to);
                        stable_position = 0;
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        stable_position = 1;
                        restore_opponents_piece(BOARD, move_to_square, White, restore_to);
                        pop_bit(BOARD.black.rooks, move_to_square);
                        pop_bit(temp_capture, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip12;
                    }
                    while (temp_move != 0) {
                        set_bit(BOARD.black.rooks, (move_to_square = find_first_set_bit(temp_move)));
                        check_for_king_check_and_continue_if_no(BOARD, depth, White, alpha, beta, eval, are_there_any_legal_moves, skip_available, stable_position);
                        pop_bit(BOARD.black.rooks, move_to_square);
                        pop_bit(temp_move, move_to_square);
                        if (skip_available)
                            goto restore_move_and_skip12;
                    }
                restore_move_and_skip12:
                    set_bit(BOARD.black.rooks, square);
                    if (skip_available)
                        goto skip_other_moves;
                }
                pop_bit(temp_black_occupancy, square);
                BOARD.castling = temp_castling;
                counter = 0;
            }
        }
        if (!are_there_any_legal_moves) {
            if (king_in_check(BOARD, White)) {
                if (White) { eval = -99999 + (DEPTH - depth); }
                else { eval = 99999 - (DEPTH - depth); }
            }
            else {
                if (White && 0 > eval) { eval = 0; }
                else if (!White && 0 < eval) { eval = 0; }
            }
        }
    skip_other_moves:;
    }
    else {
        //if (stable_position && !king_in_check(BOARD, !White))
        eval = EVAL(BOARD, depth, alpha, beta);
        /*else {
            if (!is_position_stable(BOARD, !White) && BOARD.quescent_search_depth_remaining > 0) {
                int temp_eval = -100000;
                if (White)
                    temp_eval = 100000;
                BOARD.quescent_search_depth_remaining -= 2;
                generate_movess(BOARD, depth - 1, !White, alpha, beta, temp_eval, stable_position);
                eval = temp_eval;
                BOARD.quescent_search_depth_remaining += 2;
            }
            else
                eval = EVAL(BOARD, depth);
        }*/
    }
}
void check_for_king_check_and_continue_if_no(chessboard BOARD, int depth, bool White, int& alpha, int& beta, int& eval, bool& are_there_any_legal_moves, bool& skip_available, bool stable_position) {
    int temp_eval = -100000;
    if (White)
        temp_eval = 100000;
    if (!king_in_check(BOARD, White)) {
        if (DEPTH == depth) {
            ALL_LAYER_BOARDS.board[ALL_LAYER_BOARDS.n] = BOARD;
            ALL_LAYER_BOARDS.eval[ALL_LAYER_BOARDS.n] = EVAL(BOARD, DEPTH - 1, alpha, beta);
            ALL_LAYER_BOARDS.n++;
        }
        else {
            are_there_any_legal_moves = true;
            if (BOARD.quescent_search_depth_remaining != 10) {
                if (!stable_position || king_in_check(BOARD, !White))
                    generate_movess(BOARD, 0, !White, alpha, beta, temp_eval, stable_position);
            }
            else {
                if (depth == 1 && stable_position)
                    stable_position = king_in_check(BOARD, !White);
                generate_movess(BOARD, depth - 1, !White, alpha, beta, temp_eval, stable_position);
            }
            if (White) {
                eval = max(eval, temp_eval);
                alpha = max(alpha, temp_eval);
            }
            else {
                eval = min(eval, temp_eval);
                beta = min(beta, temp_eval);
            }
            if (beta <= alpha)
                skip_available = true;
        }
    }
}
void generate_moves(chessboard BOARD, bool White, int depth, std::string& move, std::string fen) {
    std::cout << line;
    print_board(BOARD);
    std::cout << "Generating moves in this position...\n";
    int eval;
    generate_movess(BOARD, depth, White, 0, 0, eval, true);
    if (ALL_LAYER_BOARDS.n != 0) {
        std::cout << (White ? "White" : "Black") << " has " << ALL_LAYER_BOARDS.n << " available move" << ((ALL_LAYER_BOARDS.n != 1) ? "s" : "") << ":\n\n";
        for (int i = 0; i < ALL_LAYER_BOARDS.n; i++) {
            if (White)
                std::cout << change_to_human_language(get_occupancy(BOARD.white), get_occupancy(ALL_LAYER_BOARDS.board[i].white)) << "\\";
            else
                std::cout << change_to_human_language(get_occupancy(BOARD.black), get_occupancy(ALL_LAYER_BOARDS.board[i].black)) << "\\";
        }
        std::cout << "\n\nEvaluating the position...\n\n";

        sort_positions(ALL_LAYER_BOARDS, White);


        int alpha = -100000, beta = 100000, Eval = -100000;
        HOW_MANY_THREADS_AT_THE_SAME_TIME = 4;
        if (White)Eval = 100000;

        for (int i = 0; i < ALL_LAYER_BOARDS.n;) {
            for (int j = 0; (j < HOW_MANY_THREADS_AT_THE_SAME_TIME && j + i < ALL_LAYER_BOARDS.n); j++) {
                ALL_LAYER_BOARDS.eval[i + j] = Eval;
                threads.push_back(std::thread(generate_movess, ALL_LAYER_BOARDS.board[i + j], DEPTH - 1 - 4, !White, alpha, beta, std::ref(ALL_LAYER_BOARDS.eval[i + j]), true));
            }
            for (auto& thread : threads)
                if (thread.joinable())thread.join();
            for (int j = 0; (j < HOW_MANY_THREADS_AT_THE_SAME_TIME && j + i < ALL_LAYER_BOARDS.n); j++) {
                if (White) {
                    alpha = max(alpha, ALL_LAYER_BOARDS.eval[i + j]);
                }
                else {
                    beta = min(beta, ALL_LAYER_BOARDS.eval[i + j]);
                }
            }
            i += HOW_MANY_THREADS_AT_THE_SAME_TIME;
            HOW_MANY_THREADS_AT_THE_SAME_TIME += 0;
        }

        sort_positions(ALL_LAYER_BOARDS, White);
        std::cout << "Completed depth 4\n";

        alpha = -100000, beta = 100000, Eval = -100000;
        HOW_MANY_THREADS_AT_THE_SAME_TIME = 6;
        if (White)Eval = 100000;

        for (int i = 0; i < ALL_LAYER_BOARDS.n;) {
            for (int j = 0; (j < HOW_MANY_THREADS_AT_THE_SAME_TIME && j + i < ALL_LAYER_BOARDS.n); j++) {
                ALL_LAYER_BOARDS.eval[i + j] = Eval;
                threads.push_back(std::thread(generate_movess, ALL_LAYER_BOARDS.board[i + j], DEPTH - 1 - 2, !White, alpha, beta, std::ref(ALL_LAYER_BOARDS.eval[i + j]), true));
            }
            for (auto& thread : threads)
                if (thread.joinable())thread.join();
            for (int j = 0; (j < HOW_MANY_THREADS_AT_THE_SAME_TIME && j + i < ALL_LAYER_BOARDS.n); j++) {
                if (White) {
                    alpha = max(alpha, ALL_LAYER_BOARDS.eval[i + j]);
                }
                else {
                    beta = min(beta, ALL_LAYER_BOARDS.eval[i + j]);
                }
            }
            i += HOW_MANY_THREADS_AT_THE_SAME_TIME;
            HOW_MANY_THREADS_AT_THE_SAME_TIME += 0;
        }

        sort_positions(ALL_LAYER_BOARDS, White);
        std::cout << "Completed depth 6\n";

       /* int go8for_some_moves = 6;
        if (ALL_LAYER_BOARDS.n < go8for_some_moves) {
            go8for_some_moves = ALL_LAYER_BOARDS.n;
        }

        alpha = -100000, beta = 100000, Eval = -100000;
        HOW_MANY_THREADS_AT_THE_SAME_TIME = 6;
        if (White)Eval = 100000;

        for (int j = 0; j < go8for_some_moves; j++) {
            ALL_LAYER_BOARDS.eval[j] = Eval;
            threads.push_back(std::thread(generate_movess, ALL_LAYER_BOARDS.board[j], DEPTH - 1 - 1, !White, alpha, beta, std::ref(ALL_LAYER_BOARDS.eval[j]), true));
        }
        for (auto& thread : threads)
            if (thread.joinable())thread.join();

        sort_positions(ALL_LAYER_BOARDS, White);
        std::cout << "Completed depth 8 for the first\n" << go8for_some_moves<< "moves";*/




        std::cout << "\n";
        for (int i = 0; i < ALL_LAYER_BOARDS.n; i++) {
            if (White)
                std::cout << change_to_human_language(get_occupancy(BOARD.white), get_occupancy(ALL_LAYER_BOARDS.board[i].white)) << " " << ALL_LAYER_BOARDS.eval[i] << "\\";
            else
                std::cout << change_to_human_language(get_occupancy(BOARD.black), get_occupancy(ALL_LAYER_BOARDS.board[i].black)) << " " << ALL_LAYER_BOARDS.eval[i] << "\\";
        }
        std::cout << "\n\n";
        std::cout << "\nBest move: ";
        if (White) {
            if (!has_position_occured_two_times(ALL_LAYER_BOARDS.board[0]) || ALL_LAYER_BOARDS.eval[0] < 0) {
                move = change_to_human_language(get_occupancy(BOARD.white), get_occupancy(ALL_LAYER_BOARDS.board[0].white));eval = ALL_LAYER_BOARDS.eval[0];
                check_for_three_fold_repetition.push_back(ALL_LAYER_BOARDS.board[0]);
            }
            else if (!has_position_occured_two_times(ALL_LAYER_BOARDS.board[1]) && ALL_LAYER_BOARDS.n > 1) {
                move = change_to_human_language(get_occupancy(BOARD.white), get_occupancy(ALL_LAYER_BOARDS.board[1].white));eval = ALL_LAYER_BOARDS.eval[1];
                check_for_three_fold_repetition.push_back(ALL_LAYER_BOARDS.board[1]);
            }
            else if(ALL_LAYER_BOARDS.n > 2){
                move = change_to_human_language(get_occupancy(BOARD.white), get_occupancy(ALL_LAYER_BOARDS.board[2].white));eval = ALL_LAYER_BOARDS.eval[2];
                check_for_three_fold_repetition.push_back(ALL_LAYER_BOARDS.board[2]);
            }
        }
        else {
            if (!has_position_occured_two_times(ALL_LAYER_BOARDS.board[0]) || ALL_LAYER_BOARDS.eval[0] > 0) {
                move = change_to_human_language(get_occupancy(BOARD.black), get_occupancy(ALL_LAYER_BOARDS.board[0].black));eval = ALL_LAYER_BOARDS.eval[0];
                check_for_three_fold_repetition.push_back(ALL_LAYER_BOARDS.board[0]);
            }
            else if (!has_position_occured_two_times(ALL_LAYER_BOARDS.board[1]) && ALL_LAYER_BOARDS.n > 1) {
                move = change_to_human_language(get_occupancy(BOARD.black), get_occupancy(ALL_LAYER_BOARDS.board[1].black));eval = ALL_LAYER_BOARDS.eval[1];
                check_for_three_fold_repetition.push_back(ALL_LAYER_BOARDS.board[1]);
            }
            else if (ALL_LAYER_BOARDS.n > 2) {
                move = change_to_human_language(get_occupancy(BOARD.black), get_occupancy(ALL_LAYER_BOARDS.board[2].black));eval = ALL_LAYER_BOARDS.eval[2];
                check_for_three_fold_repetition.push_back(ALL_LAYER_BOARDS.board[2]);
            }
        }
        std::cout << move << "\nEval: " << std::fixed << std::setprecision(3) << eval / 100.0 << "\n\n" << line;
        ALL_LAYER_BOARDS.n = 0;
    }
    else {
        std::cout << (White ? "White" : "Black") << " has no moves in this position\nDo you want to continue?";
        std::string a;
        std::cin >> a;
    }

}
void DoTheThing(bool White, std::unordered_map<std::string, std::string> precomputed_moves) {
    WSADATA wsa_data;
    SOCKADDR_IN addr;

    WSAStartup(MAKEWORD(2, 0), &wsa_data);
    const auto server = socket(AF_INET, SOCK_STREAM, 0);

    inet_pton(AF_INET, "127.0.0.1", &addr.sin_addr.s_addr);

    addr.sin_family = AF_INET;
    addr.sin_port = htons(White ? 6969 : 6970);
    connect(server, reinterpret_cast<SOCKADDR*>(&addr), sizeof(addr));
    std::cout << "Connected to server!\n";

    char recvbuf[DEFAULT_BUFLEN];
    int recvbuflen = DEFAULT_BUFLEN;
    int result, time;
    double eval;
    std::string eh, best_move;

    do {
        result = recv(server, recvbuf, recvbuflen, 0);
        std::string message(recvbuf);
        message = message.substr(0, result);
        cout << line << "|" << message << "|\n";


        if (message.length() < 8) { std::cout << "An error occured, do you want to continue?";std::cin >> eh; }
        else if (moveCount < 18 && !precomputed_moves.empty()) {
            std::vector<std::string> split_fen = split(message, ' ');
            std::string cut_fen = split_fen[0] + ' ' + split_fen[1] + ' ' + split_fen[2] + ' ' + split_fen[3];
            auto location = precomputed_moves.find(cut_fen);
            if (location != precomputed_moves.end()) {
                cout << line << "\n";
                best_move = location->second;
                cout << "Precomputed move: \n" << best_move << "\n\n";
            }
            else {
                chessboard BOARD = initialize_chessboard(message, White, time);
                generate_moves(BOARD, White, DEPTH, best_move, cut_fen);
            }
        }
        else {
            std::vector<std::string> split_fen = split(message, ' ');
            std::string cut_fen = split_fen[0] + ' ' + split_fen[1] + ' ' + split_fen[2] + ' ' + split_fen[3];
            chessboard BOARD = initialize_chessboard(message, White, time);
            generate_moves(BOARD, White, DEPTH, best_move, cut_fen);
        }


        send(server, best_move.c_str(), best_move.length(), 0);
        moveCount += 2;
    } while (result > 0);
}
int main()
{
    std::string best_move;
    string colour;
    chessboard BOARD = initialize_chessboard();
    std::unordered_map<std::string, std::string> precomputed_moves;

    init_sliders_attacks(rook);
    init_sliders_attacks(bishop);

    read_precomputed_moves(precomputed_moves, "move_file.txt");
    /*for (const auto& eh : precomputed_moves) {
        cout <<"|" << eh.first << "|" << eh.second << "|\n";
    }*/

    DoTheThing(0, precomputed_moves);//0 for black and 1 for white

    /*
    //manual testing
    //string fen = "INSERT_FEN_HERE";
    int time;
    bool white;
    BOARD = initialize_chessboard(fen, white, time);
    generate_moves(BOARD, white, DEPTH, best_move);//*/
}
